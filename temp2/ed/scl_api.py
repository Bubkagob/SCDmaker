#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Apr  6 14:56:56 2018 by generateDS.py version 2.29.11.
# Python 3.6.4 (default, Jan  5 2018, 02:35:40)  [GCC 7.2.1 20171224]
#
# Command line options:
#   ('-o', 'scl_api.py')
#   ('-s', 'scl_sub.py')
#
# Command line arguments:
#   SCL.xsd
#
# Command line:
#   /usr/bin/generateDS.py -o "scl_api.py" -s "scl_sub.py" SCL.xsd
#
# Current working directory (os.getcwd()):
#   ed
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                return instring.encode(ExternalEncoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf-8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class tBaseElement(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, extensiontype_=None):
        self.original_tagname_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_
        self.Text = Text
        if Private is None:
            self.Private = []
        else:
            self.Private = Private
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tBaseElement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tBaseElement.subclass:
            return tBaseElement.subclass(*args_, **kwargs_)
        else:
            return tBaseElement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def add_anytypeobjs_(self, value): self.anytypeobjs_.append(value)
    def insert_anytypeobjs_(self, index, value): self._anytypeobjs_[index] = value
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_Private(self): return self.Private
    def set_Private(self, Private): self.Private = Private
    def add_Private(self, value): self.Private.append(value)
    def insert_Private_at(self, index, value): self.Private.insert(index, value)
    def replace_Private_at(self, index, value): self.Private[index] = value
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.anytypeobjs_ or
            self.Text is not None or
            self.Private
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tBaseElement', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tBaseElement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tBaseElement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tBaseElement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tBaseElement'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tBaseElement', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            self.Text.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
        for Private_ in self.Private:
            Private_.export(outfile, level, namespace_, name_='Private', pretty_print=pretty_print)
        for obj_ in self.anytypeobjs_:
            obj_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = tText.factory()
            obj_.build(child_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
        elif nodeName_ == 'Private':
            obj_ = tPrivate.factory()
            obj_.build(child_)
            self.Private.append(obj_)
            obj_.original_tagname_ = 'Private'
        else:
            obj_ = self.gds_build_any(child_, 'tBaseElement')
            if obj_ is not None:
                self.add_anytypeobjs_(obj_)
# end class tBaseElement


class tUnNaming(tBaseElement):
    subclass = None
    superclass = tBaseElement
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tUnNaming, self).__init__(anytypeobjs_, Text, Private, extensiontype_, )
        self.desc = _cast(None, desc)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tUnNaming)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tUnNaming.subclass:
            return tUnNaming.subclass(*args_, **kwargs_)
        else:
            return tUnNaming(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(tUnNaming, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tUnNaming', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tUnNaming')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tUnNaming')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tUnNaming', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tUnNaming'):
        super(tUnNaming, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tUnNaming')
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            outfile.write(' desc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.desc), input_name='desc')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tUnNaming', fromsubclass_=False, pretty_print=True):
        super(tUnNaming, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            self.desc = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tUnNaming, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tUnNaming, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tUnNaming


class tNaming(tBaseElement):
    subclass = None
    superclass = tBaseElement
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tNaming, self).__init__(anytypeobjs_, Text, Private, extensiontype_, )
        self.name = _cast(None, name)
        self.desc = _cast(None, desc)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tNaming)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tNaming.subclass:
            return tNaming.subclass(*args_, **kwargs_)
        else:
            return tNaming(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tNaming, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tNaming', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tNaming')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tNaming')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tNaming', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tNaming'):
        super(tNaming, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tNaming')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            outfile.write(' desc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.desc), input_name='desc')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tNaming', fromsubclass_=False, pretty_print=True):
        super(tNaming, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tName(self.name)    # validate type tName
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            self.desc = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tNaming, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tNaming, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tNaming


class tIDNaming(tBaseElement):
    subclass = None
    superclass = tBaseElement
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, id=None, desc=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tIDNaming, self).__init__(anytypeobjs_, Text, Private, extensiontype_, )
        self.id = _cast(None, id)
        self.desc = _cast(None, desc)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tIDNaming)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tIDNaming.subclass:
            return tIDNaming.subclass(*args_, **kwargs_)
        else:
            return tIDNaming(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_desc(self): return self.desc
    def set_desc(self, desc): self.desc = desc
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tIDNaming, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tIDNaming', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tIDNaming')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tIDNaming')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tIDNaming', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tIDNaming'):
        super(tIDNaming, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tIDNaming')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.desc is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            outfile.write(' desc=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.desc), input_name='desc')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tIDNaming', fromsubclass_=False, pretty_print=True):
        super(tIDNaming, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
            self.validate_tName(self.id)    # validate type tName
        value = find_attr_value_('desc', node)
        if value is not None and 'desc' not in already_processed:
            already_processed.add('desc')
            self.desc = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tIDNaming, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tIDNaming, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tIDNaming


class tAnyContentFromOtherNamespace(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.anytypeobjs_ = anytypeobjs_
        self.valueOf_ = valueOf_
        self.anyAttributes_ = {}
        self.extensiontype_ = extensiontype_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAnyContentFromOtherNamespace)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAnyContentFromOtherNamespace.subclass:
            return tAnyContentFromOtherNamespace.subclass(*args_, **kwargs_)
        else:
            return tAnyContentFromOtherNamespace(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_anytypeobjs_(self): return self.anytypeobjs_
    def set_anytypeobjs_(self, anytypeobjs_): self.anytypeobjs_ = anytypeobjs_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_anyAttributes_(self): return self.anyAttributes_
    def set_anyAttributes_(self, anyAttributes_): self.anyAttributes_ = anyAttributes_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.anytypeobjs_ is not None or
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAnyContentFromOtherNamespace', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAnyContentFromOtherNamespace')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAnyContentFromOtherNamespace')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAnyContentFromOtherNamespace', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAnyContentFromOtherNamespace'):
        unique_counter = 0
        for name, value in self.anyAttributes_.items():
            xsinamespaceprefix = 'xsi'
            xsinamespace1 = 'http://www.w3.org/2001/XMLSchema-instance'
            xsinamespace2 = '{%s}' % (xsinamespace1, )
            if name.startswith(xsinamespace2):
                name1 = name[len(xsinamespace2):]
                name2 = '%s:%s' % (xsinamespaceprefix, name1, )
                if name2 not in already_processed:
                    already_processed.add(name2)
                    outfile.write(' %s=%s' % (name2, quote_attrib(value), ))
            else:
                mo = re_.match(Namespace_extract_pat_, name)
                if mo is not None:
                    namespace, name = mo.group(1, 2)
                    if name not in already_processed:
                        already_processed.add(name)
                        if namespace == 'http://www.w3.org/XML/1998/namespace':
                            outfile.write(' %s=%s' % (
                                name, quote_attrib(value), ))
                        else:
                            unique_counter += 1
                            outfile.write(' xmlns:%d="%s"' % (
                                unique_counter, namespace, ))
                            outfile.write(' %d:%s=%s' % (
                                unique_counter, name, quote_attrib(value), ))
                else:
                    if name not in already_processed:
                        already_processed.add(name)
                        outfile.write(' %s=%s' % (
                            name, quote_attrib(value), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAnyContentFromOtherNamespace', fromsubclass_=False, pretty_print=True):
        if not fromsubclass_:
            for item_ in self.content_:
                item_.export(outfile, level, item_.name, namespace_, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.anytypeobjs_ is not None:
            self.anytypeobjs_.export(outfile, level, namespace_, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        self.anyAttributes_ = {}
        for name, value in attrs.items():
            if name not in already_processed:
                self.anyAttributes_[name] = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == '':
            obj_ = __ANY__.factory()
            obj_.build(child_)
            obj_ = self.mixedclass_(MixedContainer.CategoryComplex,
                MixedContainer.TypeNone, '', obj_)
            self.content_.append(obj_)
            if hasattr(self, 'add_'):
              self.add_(obj_.value)
            elif hasattr(self, 'set_'):
              self.set_(obj_.value)
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
# end class tAnyContentFromOtherNamespace


class tText(tAnyContentFromOtherNamespace):
    subclass = None
    superclass = tAnyContentFromOtherNamespace
    def __init__(self, anytypeobjs_=None, source=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(tText, self).__init__(anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.source = _cast(None, source)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tText)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tText.subclass:
            return tText.subclass(*args_, **kwargs_)
        else:
            return tText(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tText, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tText', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tText')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tText')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tText', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tText'):
        super(tText, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tText')
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tText', fromsubclass_=False, pretty_print=True):
        super(tText, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        super(tText, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(tText, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tText


class tPrivate(tAnyContentFromOtherNamespace):
    subclass = None
    superclass = tAnyContentFromOtherNamespace
    def __init__(self, anytypeobjs_=None, type_=None, source=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(tPrivate, self).__init__(anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.type_ = _cast(None, type_)
        self.source = _cast(None, source)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tPrivate)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tPrivate.subclass:
            return tPrivate.subclass(*args_, **kwargs_)
        else:
            return tPrivate(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tPrivate, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tPrivate', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tPrivate')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tPrivate')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tPrivate', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tPrivate'):
        super(tPrivate, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tPrivate')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.source is not None and 'source' not in already_processed:
            already_processed.add('source')
            outfile.write(' source=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.source), input_name='source')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tPrivate', fromsubclass_=False, pretty_print=True):
        super(tPrivate, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.add('source')
            self.source = value
        super(tPrivate, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(tPrivate, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tPrivate


class tHeader(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, version=None, revision='', toolID=None, nameStructure='IEDName', Text=None, History=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.version = _cast(None, version)
        self.revision = _cast(None, revision)
        self.toolID = _cast(None, toolID)
        self.nameStructure = _cast(None, nameStructure)
        self.Text = Text
        self.History = History
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tHeader)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tHeader.subclass:
            return tHeader.subclass(*args_, **kwargs_)
        else:
            return tHeader(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Text(self): return self.Text
    def set_Text(self, Text): self.Text = Text
    def get_History(self): return self.History
    def set_History(self, History): self.History = History
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_revision(self): return self.revision
    def set_revision(self, revision): self.revision = revision
    def get_toolID(self): return self.toolID
    def set_toolID(self, toolID): self.toolID = toolID
    def get_nameStructure(self): return self.nameStructure
    def set_nameStructure(self, nameStructure): self.nameStructure = nameStructure
    def hasContent_(self):
        if (
            self.Text is not None or
            self.History is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tHeader', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tHeader')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tHeader')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tHeader', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tHeader'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.id), input_name='id')), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.revision != "" and 'revision' not in already_processed:
            already_processed.add('revision')
            outfile.write(' revision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.revision), input_name='revision')), ))
        if self.toolID is not None and 'toolID' not in already_processed:
            already_processed.add('toolID')
            outfile.write(' toolID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.toolID), input_name='toolID')), ))
        if self.nameStructure != "IEDName" and 'nameStructure' not in already_processed:
            already_processed.add('nameStructure')
            outfile.write(' nameStructure=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nameStructure), input_name='nameStructure')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tHeader', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Text is not None:
            self.Text.export(outfile, level, namespace_, name_='Text', pretty_print=pretty_print)
        if self.History is not None:
            self.History.export(outfile, level, namespace_, name_='History', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('revision', node)
        if value is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            self.revision = value
        value = find_attr_value_('toolID', node)
        if value is not None and 'toolID' not in already_processed:
            already_processed.add('toolID')
            self.toolID = value
        value = find_attr_value_('nameStructure', node)
        if value is not None and 'nameStructure' not in already_processed:
            already_processed.add('nameStructure')
            self.nameStructure = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Text':
            obj_ = tText.factory()
            obj_.build(child_)
            self.Text = obj_
            obj_.original_tagname_ = 'Text'
        elif nodeName_ == 'History':
            obj_ = HistoryType.factory()
            obj_.build(child_)
            self.History = obj_
            obj_.original_tagname_ = 'History'
# end class tHeader


class tHitem(tAnyContentFromOtherNamespace):
    subclass = None
    superclass = tAnyContentFromOtherNamespace
    def __init__(self, anytypeobjs_=None, version=None, revision=None, when=None, who=None, what=None, why=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(tHitem, self).__init__(anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.version = _cast(None, version)
        self.revision = _cast(None, revision)
        self.when = _cast(None, when)
        self.who = _cast(None, who)
        self.what = _cast(None, what)
        self.why = _cast(None, why)
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tHitem)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tHitem.subclass:
            return tHitem.subclass(*args_, **kwargs_)
        else:
            return tHitem(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_revision(self): return self.revision
    def set_revision(self, revision): self.revision = revision
    def get_when(self): return self.when
    def set_when(self, when): self.when = when
    def get_who(self): return self.who
    def set_who(self, who): self.who = who
    def get_what(self): return self.what
    def set_what(self, what): self.what = what
    def get_why(self): return self.why
    def set_why(self, why): self.why = why
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tHitem, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tHitem', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tHitem')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tHitem')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tHitem', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tHitem'):
        super(tHitem, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tHitem')
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.version), input_name='version')), ))
        if self.revision is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            outfile.write(' revision=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.revision), input_name='revision')), ))
        if self.when is not None and 'when' not in already_processed:
            already_processed.add('when')
            outfile.write(' when=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.when), input_name='when')), ))
        if self.who is not None and 'who' not in already_processed:
            already_processed.add('who')
            outfile.write(' who=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.who), input_name='who')), ))
        if self.what is not None and 'what' not in already_processed:
            already_processed.add('what')
            outfile.write(' what=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.what), input_name='what')), ))
        if self.why is not None and 'why' not in already_processed:
            already_processed.add('why')
            outfile.write(' why=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.why), input_name='why')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tHitem', fromsubclass_=False, pretty_print=True):
        super(tHitem, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('revision', node)
        if value is not None and 'revision' not in already_processed:
            already_processed.add('revision')
            self.revision = value
        value = find_attr_value_('when', node)
        if value is not None and 'when' not in already_processed:
            already_processed.add('when')
            self.when = value
        value = find_attr_value_('who', node)
        if value is not None and 'who' not in already_processed:
            already_processed.add('who')
            self.who = value
        value = find_attr_value_('what', node)
        if value is not None and 'what' not in already_processed:
            already_processed.add('what')
            self.what = value
        value = find_attr_value_('why', node)
        if value is not None and 'why' not in already_processed:
            already_processed.add('why')
            self.why = value
        super(tHitem, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(tHitem, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tHitem


class tVal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, sGroup=None, valueOf_=None):
        self.original_tagname_ = None
        self.sGroup = _cast(int, sGroup)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tVal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tVal.subclass:
            return tVal.subclass(*args_, **kwargs_)
        else:
            return tVal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_sGroup(self): return self.sGroup
    def set_sGroup(self, sGroup): self.sGroup = sGroup
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tVal', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tVal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tVal')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tVal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tVal'):
        if self.sGroup is not None and 'sGroup' not in already_processed:
            already_processed.add('sGroup')
            outfile.write(' sGroup="%s"' % self.gds_format_integer(self.sGroup, input_name='sGroup'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tVal', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('sGroup', node)
        if value is not None and 'sGroup' not in already_processed:
            already_processed.add('sGroup')
            try:
                self.sGroup = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tVal


class tValueWithUnit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, unit=None, multiplier='', valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.unit = _cast(None, unit)
        self.multiplier = _cast(None, multiplier)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tValueWithUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tValueWithUnit.subclass:
            return tValueWithUnit.subclass(*args_, **kwargs_)
        else:
            return tValueWithUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tSIUnitEnum(self, value):
        # Validate type tSIUnitEnum, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'm', 'kg', 's', 'A', 'K', 'mol', 'cd', 'deg', 'rad', 'sr', 'Gy', 'q', '°C', 'Sv', 'F', 'C', 'S', 'H', 'V', 'ohm', 'J', 'N', 'Hz', 'lx', 'Lm', 'Wb', 'T', 'W', 'Pa', 'm^2', 'm^3', 'm/s', 'm/s^2', 'm^3/s', 'm/m^3', 'M', 'kg/m^3', 'm^2/s', 'W/m K', 'J/K', 'ppm', 's^-1', 'rad/s', 'VA', 'Watts', 'VAr', 'phi', 'cos_phi', 'Vs', 'V^2', 'As', 'A^2', 'A^2 s', 'VAh', 'Wh', 'VArh', 'V/Hz', 'b/s']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tSIUnitEnum' % {"value" : value.encode("utf-8")} )
    def validate_tUnitMultiplierEnum(self, value):
        # Validate type tUnitMultiplierEnum, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['', 'm', 'k', 'M', 'mu', 'y', 'z', 'a', 'f', 'p', 'n', 'c', 'd', 'da', 'h', 'G', 'T', 'P', 'E', 'Z', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tUnitMultiplierEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tValueWithUnit', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tValueWithUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tValueWithUnit')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tValueWithUnit', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tValueWithUnit'):
        if self.unit is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.multiplier != "" and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier=%s' % (quote_attrib(self.multiplier), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tValueWithUnit', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_tSIUnitEnum(self.unit)    # validate type tSIUnitEnum
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            self.multiplier = value
            self.validate_tUnitMultiplierEnum(self.multiplier)    # validate type tUnitMultiplierEnum
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tValueWithUnit


class tVoltage(tValueWithUnit):
    subclass = None
    superclass = tValueWithUnit
    def __init__(self, unit=None, multiplier='', valueOf_=None):
        self.original_tagname_ = None
        super(tVoltage, self).__init__(unit, multiplier, valueOf_, )
        self.unit = _cast(None, unit)
        self.multiplier = _cast(None, multiplier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tVoltage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tVoltage.subclass:
            return tVoltage.subclass(*args_, **kwargs_)
        else:
            return tVoltage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tSIUnitEnum(self, value):
        # Validate type tSIUnitEnum, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'm', 'kg', 's', 'A', 'K', 'mol', 'cd', 'deg', 'rad', 'sr', 'Gy', 'q', '°C', 'Sv', 'F', 'C', 'S', 'H', 'V', 'ohm', 'J', 'N', 'Hz', 'lx', 'Lm', 'Wb', 'T', 'W', 'Pa', 'm^2', 'm^3', 'm/s', 'm/s^2', 'm^3/s', 'm/m^3', 'M', 'kg/m^3', 'm^2/s', 'W/m K', 'J/K', 'ppm', 's^-1', 'rad/s', 'VA', 'Watts', 'VAr', 'phi', 'cos_phi', 'Vs', 'V^2', 'As', 'A^2', 'A^2 s', 'VAh', 'Wh', 'VArh', 'V/Hz', 'b/s']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tSIUnitEnum' % {"value" : value.encode("utf-8")} )
    def validate_tUnitMultiplierEnum(self, value):
        # Validate type tUnitMultiplierEnum, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['', 'm', 'k', 'M', 'mu', 'y', 'z', 'a', 'f', 'p', 'n', 'c', 'd', 'da', 'h', 'G', 'T', 'P', 'E', 'Z', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tUnitMultiplierEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tVoltage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tVoltage', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tVoltage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tVoltage')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tVoltage', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tVoltage'):
        super(tVoltage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tVoltage')
        if self.unit != "V" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.multiplier != "" and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier=%s' % (quote_attrib(self.multiplier), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tVoltage', fromsubclass_=False, pretty_print=True):
        super(tVoltage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_tSIUnitEnum(self.unit)    # validate type tSIUnitEnum
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            self.multiplier = value
            self.validate_tUnitMultiplierEnum(self.multiplier)    # validate type tUnitMultiplierEnum
        super(tVoltage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tVoltage


class tBitRateInMbPerSec(tValueWithUnit):
    subclass = None
    superclass = tValueWithUnit
    def __init__(self, unit=None, multiplier='', valueOf_=None):
        self.original_tagname_ = None
        super(tBitRateInMbPerSec, self).__init__(unit, multiplier, valueOf_, )
        self.unit = _cast(None, unit)
        self.multiplier = _cast(None, multiplier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tBitRateInMbPerSec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tBitRateInMbPerSec.subclass:
            return tBitRateInMbPerSec.subclass(*args_, **kwargs_)
        else:
            return tBitRateInMbPerSec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tSIUnitEnum(self, value):
        # Validate type tSIUnitEnum, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'm', 'kg', 's', 'A', 'K', 'mol', 'cd', 'deg', 'rad', 'sr', 'Gy', 'q', '°C', 'Sv', 'F', 'C', 'S', 'H', 'V', 'ohm', 'J', 'N', 'Hz', 'lx', 'Lm', 'Wb', 'T', 'W', 'Pa', 'm^2', 'm^3', 'm/s', 'm/s^2', 'm^3/s', 'm/m^3', 'M', 'kg/m^3', 'm^2/s', 'W/m K', 'J/K', 'ppm', 's^-1', 'rad/s', 'VA', 'Watts', 'VAr', 'phi', 'cos_phi', 'Vs', 'V^2', 'As', 'A^2', 'A^2 s', 'VAh', 'Wh', 'VArh', 'V/Hz', 'b/s']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tSIUnitEnum' % {"value" : value.encode("utf-8")} )
    def validate_tUnitMultiplierEnum(self, value):
        # Validate type tUnitMultiplierEnum, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['', 'm', 'k', 'M', 'mu', 'y', 'z', 'a', 'f', 'p', 'n', 'c', 'd', 'da', 'h', 'G', 'T', 'P', 'E', 'Z', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tUnitMultiplierEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tBitRateInMbPerSec, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tBitRateInMbPerSec', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tBitRateInMbPerSec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tBitRateInMbPerSec')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tBitRateInMbPerSec', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tBitRateInMbPerSec'):
        super(tBitRateInMbPerSec, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tBitRateInMbPerSec')
        if self.unit != "b/s" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.multiplier != "M" and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier=%s' % (quote_attrib(self.multiplier), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tBitRateInMbPerSec', fromsubclass_=False, pretty_print=True):
        super(tBitRateInMbPerSec, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_tSIUnitEnum(self.unit)    # validate type tSIUnitEnum
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            self.multiplier = value
            self.validate_tUnitMultiplierEnum(self.multiplier)    # validate type tUnitMultiplierEnum
        super(tBitRateInMbPerSec, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tBitRateInMbPerSec


class tDurationInSec(tValueWithUnit):
    subclass = None
    superclass = tValueWithUnit
    def __init__(self, unit=None, multiplier='', valueOf_=None):
        self.original_tagname_ = None
        super(tDurationInSec, self).__init__(unit, multiplier, valueOf_, )
        self.unit = _cast(None, unit)
        self.multiplier = _cast(None, multiplier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDurationInSec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDurationInSec.subclass:
            return tDurationInSec.subclass(*args_, **kwargs_)
        else:
            return tDurationInSec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tSIUnitEnum(self, value):
        # Validate type tSIUnitEnum, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'm', 'kg', 's', 'A', 'K', 'mol', 'cd', 'deg', 'rad', 'sr', 'Gy', 'q', '°C', 'Sv', 'F', 'C', 'S', 'H', 'V', 'ohm', 'J', 'N', 'Hz', 'lx', 'Lm', 'Wb', 'T', 'W', 'Pa', 'm^2', 'm^3', 'm/s', 'm/s^2', 'm^3/s', 'm/m^3', 'M', 'kg/m^3', 'm^2/s', 'W/m K', 'J/K', 'ppm', 's^-1', 'rad/s', 'VA', 'Watts', 'VAr', 'phi', 'cos_phi', 'Vs', 'V^2', 'As', 'A^2', 'A^2 s', 'VAh', 'Wh', 'VArh', 'V/Hz', 'b/s']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tSIUnitEnum' % {"value" : value.encode("utf-8")} )
    def validate_tUnitMultiplierEnum(self, value):
        # Validate type tUnitMultiplierEnum, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['', 'm', 'k', 'M', 'mu', 'y', 'z', 'a', 'f', 'p', 'n', 'c', 'd', 'da', 'h', 'G', 'T', 'P', 'E', 'Z', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tUnitMultiplierEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tDurationInSec, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDurationInSec', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDurationInSec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDurationInSec')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDurationInSec', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDurationInSec'):
        super(tDurationInSec, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDurationInSec')
        if self.unit != "s" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.multiplier != "" and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier=%s' % (quote_attrib(self.multiplier), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDurationInSec', fromsubclass_=False, pretty_print=True):
        super(tDurationInSec, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_tSIUnitEnum(self.unit)    # validate type tSIUnitEnum
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            self.multiplier = value
            self.validate_tUnitMultiplierEnum(self.multiplier)    # validate type tUnitMultiplierEnum
        super(tDurationInSec, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tDurationInSec


class tDurationInMilliSec(tValueWithUnit):
    subclass = None
    superclass = tValueWithUnit
    def __init__(self, unit=None, multiplier='', valueOf_=None):
        self.original_tagname_ = None
        super(tDurationInMilliSec, self).__init__(unit, multiplier, valueOf_, )
        self.unit = _cast(None, unit)
        self.multiplier = _cast(None, multiplier)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDurationInMilliSec)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDurationInMilliSec.subclass:
            return tDurationInMilliSec.subclass(*args_, **kwargs_)
        else:
            return tDurationInMilliSec(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tSIUnitEnum(self, value):
        # Validate type tSIUnitEnum, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['none', 'm', 'kg', 's', 'A', 'K', 'mol', 'cd', 'deg', 'rad', 'sr', 'Gy', 'q', '°C', 'Sv', 'F', 'C', 'S', 'H', 'V', 'ohm', 'J', 'N', 'Hz', 'lx', 'Lm', 'Wb', 'T', 'W', 'Pa', 'm^2', 'm^3', 'm/s', 'm/s^2', 'm^3/s', 'm/m^3', 'M', 'kg/m^3', 'm^2/s', 'W/m K', 'J/K', 'ppm', 's^-1', 'rad/s', 'VA', 'Watts', 'VAr', 'phi', 'cos_phi', 'Vs', 'V^2', 'As', 'A^2', 'A^2 s', 'VAh', 'Wh', 'VArh', 'V/Hz', 'b/s']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tSIUnitEnum' % {"value" : value.encode("utf-8")} )
    def validate_tUnitMultiplierEnum(self, value):
        # Validate type tUnitMultiplierEnum, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['', 'm', 'k', 'M', 'mu', 'y', 'z', 'a', 'f', 'p', 'n', 'c', 'd', 'da', 'h', 'G', 'T', 'P', 'E', 'Z', 'Y']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tUnitMultiplierEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tDurationInMilliSec, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDurationInMilliSec', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDurationInMilliSec')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDurationInMilliSec')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDurationInMilliSec', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDurationInMilliSec'):
        super(tDurationInMilliSec, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDurationInMilliSec')
        if self.unit != "s" and 'unit' not in already_processed:
            already_processed.add('unit')
            outfile.write(' unit=%s' % (quote_attrib(self.unit), ))
        if self.multiplier != "m" and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            outfile.write(' multiplier=%s' % (quote_attrib(self.multiplier), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDurationInMilliSec', fromsubclass_=False, pretty_print=True):
        super(tDurationInMilliSec, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('unit', node)
        if value is not None and 'unit' not in already_processed:
            already_processed.add('unit')
            self.unit = value
            self.unit = ' '.join(self.unit.split())
            self.validate_tSIUnitEnum(self.unit)    # validate type tSIUnitEnum
        value = find_attr_value_('multiplier', node)
        if value is not None and 'multiplier' not in already_processed:
            already_processed.add('multiplier')
            self.multiplier = value
            self.validate_tUnitMultiplierEnum(self.multiplier)    # validate type tUnitMultiplierEnum
        super(tDurationInMilliSec, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tDurationInMilliSec


class tIED(tNaming):
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, type_=None, manufacturer=None, configVersion=None, owner=None, Services=None, AccessPoint=None):
        self.original_tagname_ = None
        super(tIED, self).__init__(anytypeobjs_, Text, Private, name, desc, )
        self.type_ = _cast(None, type_)
        self.manufacturer = _cast(None, manufacturer)
        self.configVersion = _cast(None, configVersion)
        self.owner = _cast(None, owner)
        self.Services = Services
        if AccessPoint is None:
            self.AccessPoint = []
        else:
            self.AccessPoint = AccessPoint
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tIED)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tIED.subclass:
            return tIED.subclass(*args_, **kwargs_)
        else:
            return tIED(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Services(self): return self.Services
    def set_Services(self, Services): self.Services = Services
    def get_AccessPoint(self): return self.AccessPoint
    def set_AccessPoint(self, AccessPoint): self.AccessPoint = AccessPoint
    def add_AccessPoint(self, value): self.AccessPoint.append(value)
    def insert_AccessPoint_at(self, index, value): self.AccessPoint.insert(index, value)
    def replace_AccessPoint_at(self, index, value): self.AccessPoint[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_manufacturer(self): return self.manufacturer
    def set_manufacturer(self, manufacturer): self.manufacturer = manufacturer
    def get_configVersion(self): return self.configVersion
    def set_configVersion(self, configVersion): self.configVersion = configVersion
    def get_owner(self): return self.owner
    def set_owner(self, owner): self.owner = owner
    def hasContent_(self):
        if (
            self.Services is not None or
            self.AccessPoint or
            super(tIED, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tIED', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tIED')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tIED')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tIED', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tIED'):
        super(tIED, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tIED')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.manufacturer is not None and 'manufacturer' not in already_processed:
            already_processed.add('manufacturer')
            outfile.write(' manufacturer=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.manufacturer), input_name='manufacturer')), ))
        if self.configVersion is not None and 'configVersion' not in already_processed:
            already_processed.add('configVersion')
            outfile.write(' configVersion=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.configVersion), input_name='configVersion')), ))
        if self.owner is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            outfile.write(' owner=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.owner), input_name='owner')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tIED', fromsubclass_=False, pretty_print=True):
        super(tIED, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Services is not None:
            self.Services.export(outfile, level, namespace_, name_='Services', pretty_print=pretty_print)
        for AccessPoint_ in self.AccessPoint:
            AccessPoint_.export(outfile, level, namespace_, name_='AccessPoint', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('manufacturer', node)
        if value is not None and 'manufacturer' not in already_processed:
            already_processed.add('manufacturer')
            self.manufacturer = value
        value = find_attr_value_('configVersion', node)
        if value is not None and 'configVersion' not in already_processed:
            already_processed.add('configVersion')
            self.configVersion = value
        value = find_attr_value_('owner', node)
        if value is not None and 'owner' not in already_processed:
            already_processed.add('owner')
            self.owner = value
        super(tIED, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Services':
            obj_ = tServices.factory()
            obj_.build(child_)
            self.Services = obj_
            obj_.original_tagname_ = 'Services'
        elif nodeName_ == 'AccessPoint':
            obj_ = tAccessPoint.factory()
            obj_.build(child_)
            self.AccessPoint.append(obj_)
            obj_.original_tagname_ = 'AccessPoint'
        super(tIED, self).buildChildren(child_, node, nodeName_, True)
# end class tIED


class tServices(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DynAssociation=None, SettingGroups=None, GetDirectory=None, GetDataObjectDefinition=None, DataObjectDirectory=None, GetDataSetValue=None, SetDataSetValue=None, DataSetDirectory=None, ConfDataSet=None, DynDataSet=None, ReadWrite=None, TimerActivatedControl=None, ConfReportControl=None, GetCBValues=None, ConfLogControl=None, ReportSettings=None, LogSettings=None, GSESettings=None, SMVSettings=None, GSEDir=None, GOOSE=None, GSSE=None, FileHandling=None, ConfLNs=None):
        self.original_tagname_ = None
        self.DynAssociation = DynAssociation
        self.SettingGroups = SettingGroups
        self.GetDirectory = GetDirectory
        self.GetDataObjectDefinition = GetDataObjectDefinition
        self.DataObjectDirectory = DataObjectDirectory
        self.GetDataSetValue = GetDataSetValue
        self.SetDataSetValue = SetDataSetValue
        self.DataSetDirectory = DataSetDirectory
        self.ConfDataSet = ConfDataSet
        self.DynDataSet = DynDataSet
        self.ReadWrite = ReadWrite
        self.TimerActivatedControl = TimerActivatedControl
        self.ConfReportControl = ConfReportControl
        self.GetCBValues = GetCBValues
        self.ConfLogControl = ConfLogControl
        self.ReportSettings = ReportSettings
        self.LogSettings = LogSettings
        self.GSESettings = GSESettings
        self.SMVSettings = SMVSettings
        self.GSEDir = GSEDir
        self.GOOSE = GOOSE
        self.GSSE = GSSE
        self.FileHandling = FileHandling
        self.ConfLNs = ConfLNs
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServices)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServices.subclass:
            return tServices.subclass(*args_, **kwargs_)
        else:
            return tServices(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DynAssociation(self): return self.DynAssociation
    def set_DynAssociation(self, DynAssociation): self.DynAssociation = DynAssociation
    def get_SettingGroups(self): return self.SettingGroups
    def set_SettingGroups(self, SettingGroups): self.SettingGroups = SettingGroups
    def get_GetDirectory(self): return self.GetDirectory
    def set_GetDirectory(self, GetDirectory): self.GetDirectory = GetDirectory
    def get_GetDataObjectDefinition(self): return self.GetDataObjectDefinition
    def set_GetDataObjectDefinition(self, GetDataObjectDefinition): self.GetDataObjectDefinition = GetDataObjectDefinition
    def get_DataObjectDirectory(self): return self.DataObjectDirectory
    def set_DataObjectDirectory(self, DataObjectDirectory): self.DataObjectDirectory = DataObjectDirectory
    def get_GetDataSetValue(self): return self.GetDataSetValue
    def set_GetDataSetValue(self, GetDataSetValue): self.GetDataSetValue = GetDataSetValue
    def get_SetDataSetValue(self): return self.SetDataSetValue
    def set_SetDataSetValue(self, SetDataSetValue): self.SetDataSetValue = SetDataSetValue
    def get_DataSetDirectory(self): return self.DataSetDirectory
    def set_DataSetDirectory(self, DataSetDirectory): self.DataSetDirectory = DataSetDirectory
    def get_ConfDataSet(self): return self.ConfDataSet
    def set_ConfDataSet(self, ConfDataSet): self.ConfDataSet = ConfDataSet
    def get_DynDataSet(self): return self.DynDataSet
    def set_DynDataSet(self, DynDataSet): self.DynDataSet = DynDataSet
    def get_ReadWrite(self): return self.ReadWrite
    def set_ReadWrite(self, ReadWrite): self.ReadWrite = ReadWrite
    def get_TimerActivatedControl(self): return self.TimerActivatedControl
    def set_TimerActivatedControl(self, TimerActivatedControl): self.TimerActivatedControl = TimerActivatedControl
    def get_ConfReportControl(self): return self.ConfReportControl
    def set_ConfReportControl(self, ConfReportControl): self.ConfReportControl = ConfReportControl
    def get_GetCBValues(self): return self.GetCBValues
    def set_GetCBValues(self, GetCBValues): self.GetCBValues = GetCBValues
    def get_ConfLogControl(self): return self.ConfLogControl
    def set_ConfLogControl(self, ConfLogControl): self.ConfLogControl = ConfLogControl
    def get_ReportSettings(self): return self.ReportSettings
    def set_ReportSettings(self, ReportSettings): self.ReportSettings = ReportSettings
    def get_LogSettings(self): return self.LogSettings
    def set_LogSettings(self, LogSettings): self.LogSettings = LogSettings
    def get_GSESettings(self): return self.GSESettings
    def set_GSESettings(self, GSESettings): self.GSESettings = GSESettings
    def get_SMVSettings(self): return self.SMVSettings
    def set_SMVSettings(self, SMVSettings): self.SMVSettings = SMVSettings
    def get_GSEDir(self): return self.GSEDir
    def set_GSEDir(self, GSEDir): self.GSEDir = GSEDir
    def get_GOOSE(self): return self.GOOSE
    def set_GOOSE(self, GOOSE): self.GOOSE = GOOSE
    def get_GSSE(self): return self.GSSE
    def set_GSSE(self, GSSE): self.GSSE = GSSE
    def get_FileHandling(self): return self.FileHandling
    def set_FileHandling(self, FileHandling): self.FileHandling = FileHandling
    def get_ConfLNs(self): return self.ConfLNs
    def set_ConfLNs(self, ConfLNs): self.ConfLNs = ConfLNs
    def hasContent_(self):
        if (
            self.DynAssociation is not None or
            self.SettingGroups is not None or
            self.GetDirectory is not None or
            self.GetDataObjectDefinition is not None or
            self.DataObjectDirectory is not None or
            self.GetDataSetValue is not None or
            self.SetDataSetValue is not None or
            self.DataSetDirectory is not None or
            self.ConfDataSet is not None or
            self.DynDataSet is not None or
            self.ReadWrite is not None or
            self.TimerActivatedControl is not None or
            self.ConfReportControl is not None or
            self.GetCBValues is not None or
            self.ConfLogControl is not None or
            self.ReportSettings is not None or
            self.LogSettings is not None or
            self.GSESettings is not None or
            self.SMVSettings is not None or
            self.GSEDir is not None or
            self.GOOSE is not None or
            self.GSSE is not None or
            self.FileHandling is not None or
            self.ConfLNs is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServices', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServices')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServices')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServices', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServices'):
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServices', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DynAssociation is not None:
            self.DynAssociation.export(outfile, level, namespace_, name_='DynAssociation', pretty_print=pretty_print)
        if self.SettingGroups is not None:
            self.SettingGroups.export(outfile, level, namespace_, name_='SettingGroups', pretty_print=pretty_print)
        if self.GetDirectory is not None:
            self.GetDirectory.export(outfile, level, namespace_, name_='GetDirectory', pretty_print=pretty_print)
        if self.GetDataObjectDefinition is not None:
            self.GetDataObjectDefinition.export(outfile, level, namespace_, name_='GetDataObjectDefinition', pretty_print=pretty_print)
        if self.DataObjectDirectory is not None:
            self.DataObjectDirectory.export(outfile, level, namespace_, name_='DataObjectDirectory', pretty_print=pretty_print)
        if self.GetDataSetValue is not None:
            self.GetDataSetValue.export(outfile, level, namespace_, name_='GetDataSetValue', pretty_print=pretty_print)
        if self.SetDataSetValue is not None:
            self.SetDataSetValue.export(outfile, level, namespace_, name_='SetDataSetValue', pretty_print=pretty_print)
        if self.DataSetDirectory is not None:
            self.DataSetDirectory.export(outfile, level, namespace_, name_='DataSetDirectory', pretty_print=pretty_print)
        if self.ConfDataSet is not None:
            self.ConfDataSet.export(outfile, level, namespace_, name_='ConfDataSet', pretty_print=pretty_print)
        if self.DynDataSet is not None:
            self.DynDataSet.export(outfile, level, namespace_, name_='DynDataSet', pretty_print=pretty_print)
        if self.ReadWrite is not None:
            self.ReadWrite.export(outfile, level, namespace_, name_='ReadWrite', pretty_print=pretty_print)
        if self.TimerActivatedControl is not None:
            self.TimerActivatedControl.export(outfile, level, namespace_, name_='TimerActivatedControl', pretty_print=pretty_print)
        if self.ConfReportControl is not None:
            self.ConfReportControl.export(outfile, level, namespace_, name_='ConfReportControl', pretty_print=pretty_print)
        if self.GetCBValues is not None:
            self.GetCBValues.export(outfile, level, namespace_, name_='GetCBValues', pretty_print=pretty_print)
        if self.ConfLogControl is not None:
            self.ConfLogControl.export(outfile, level, namespace_, name_='ConfLogControl', pretty_print=pretty_print)
        if self.ReportSettings is not None:
            self.ReportSettings.export(outfile, level, namespace_, name_='ReportSettings', pretty_print=pretty_print)
        if self.LogSettings is not None:
            self.LogSettings.export(outfile, level, namespace_, name_='LogSettings', pretty_print=pretty_print)
        if self.GSESettings is not None:
            self.GSESettings.export(outfile, level, namespace_, name_='GSESettings', pretty_print=pretty_print)
        if self.SMVSettings is not None:
            self.SMVSettings.export(outfile, level, namespace_, name_='SMVSettings', pretty_print=pretty_print)
        if self.GSEDir is not None:
            self.GSEDir.export(outfile, level, namespace_, name_='GSEDir', pretty_print=pretty_print)
        if self.GOOSE is not None:
            self.GOOSE.export(outfile, level, namespace_, name_='GOOSE', pretty_print=pretty_print)
        if self.GSSE is not None:
            self.GSSE.export(outfile, level, namespace_, name_='GSSE', pretty_print=pretty_print)
        if self.FileHandling is not None:
            self.FileHandling.export(outfile, level, namespace_, name_='FileHandling', pretty_print=pretty_print)
        if self.ConfLNs is not None:
            self.ConfLNs.export(outfile, level, namespace_, name_='ConfLNs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DynAssociation':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.DynAssociation = obj_
            obj_.original_tagname_ = 'DynAssociation'
        elif nodeName_ == 'SettingGroups':
            obj_ = SettingGroupsType.factory()
            obj_.build(child_)
            self.SettingGroups = obj_
            obj_.original_tagname_ = 'SettingGroups'
        elif nodeName_ == 'GetDirectory':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.GetDirectory = obj_
            obj_.original_tagname_ = 'GetDirectory'
        elif nodeName_ == 'GetDataObjectDefinition':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.GetDataObjectDefinition = obj_
            obj_.original_tagname_ = 'GetDataObjectDefinition'
        elif nodeName_ == 'DataObjectDirectory':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.DataObjectDirectory = obj_
            obj_.original_tagname_ = 'DataObjectDirectory'
        elif nodeName_ == 'GetDataSetValue':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.GetDataSetValue = obj_
            obj_.original_tagname_ = 'GetDataSetValue'
        elif nodeName_ == 'SetDataSetValue':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.SetDataSetValue = obj_
            obj_.original_tagname_ = 'SetDataSetValue'
        elif nodeName_ == 'DataSetDirectory':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.DataSetDirectory = obj_
            obj_.original_tagname_ = 'DataSetDirectory'
        elif nodeName_ == 'ConfDataSet':
            obj_ = tServiceWithMaxAndMaxAttributesAndModify.factory()
            obj_.build(child_)
            self.ConfDataSet = obj_
            obj_.original_tagname_ = 'ConfDataSet'
        elif nodeName_ == 'DynDataSet':
            class_obj_ = self.get_class_obj_(child_, tServiceWithMaxAndMaxAttributes)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.DynDataSet = obj_
            obj_.original_tagname_ = 'DynDataSet'
        elif nodeName_ == 'ReadWrite':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.ReadWrite = obj_
            obj_.original_tagname_ = 'ReadWrite'
        elif nodeName_ == 'TimerActivatedControl':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.TimerActivatedControl = obj_
            obj_.original_tagname_ = 'TimerActivatedControl'
        elif nodeName_ == 'ConfReportControl':
            class_obj_ = self.get_class_obj_(child_, tServiceWithMax)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfReportControl = obj_
            obj_.original_tagname_ = 'ConfReportControl'
        elif nodeName_ == 'GetCBValues':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.GetCBValues = obj_
            obj_.original_tagname_ = 'GetCBValues'
        elif nodeName_ == 'ConfLogControl':
            class_obj_ = self.get_class_obj_(child_, tServiceWithMax)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ConfLogControl = obj_
            obj_.original_tagname_ = 'ConfLogControl'
        elif nodeName_ == 'ReportSettings':
            obj_ = tReportSettings.factory()
            obj_.build(child_)
            self.ReportSettings = obj_
            obj_.original_tagname_ = 'ReportSettings'
        elif nodeName_ == 'LogSettings':
            obj_ = tLogSettings.factory()
            obj_.build(child_)
            self.LogSettings = obj_
            obj_.original_tagname_ = 'LogSettings'
        elif nodeName_ == 'GSESettings':
            obj_ = tGSESettings.factory()
            obj_.build(child_)
            self.GSESettings = obj_
            obj_.original_tagname_ = 'GSESettings'
        elif nodeName_ == 'SMVSettings':
            obj_ = tSMVSettings.factory()
            obj_.build(child_)
            self.SMVSettings = obj_
            obj_.original_tagname_ = 'SMVSettings'
        elif nodeName_ == 'GSEDir':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.GSEDir = obj_
            obj_.original_tagname_ = 'GSEDir'
        elif nodeName_ == 'GOOSE':
            obj_ = tServiceWithMaxAndClient.factory()
            obj_.build(child_)
            self.GOOSE = obj_
            obj_.original_tagname_ = 'GOOSE'
        elif nodeName_ == 'GSSE':
            obj_ = tServiceWithMaxAndClient.factory()
            obj_.build(child_)
            self.GSSE = obj_
            obj_.original_tagname_ = 'GSSE'
        elif nodeName_ == 'FileHandling':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.FileHandling = obj_
            obj_.original_tagname_ = 'FileHandling'
        elif nodeName_ == 'ConfLNs':
            obj_ = tConfLNs.factory()
            obj_.build(child_)
            self.ConfLNs = obj_
            obj_.original_tagname_ = 'ConfLNs'
# end class tServices


class tAccessPoint(tNaming):
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, router=False, clock=False, Server=None, LN=None):
        self.original_tagname_ = None
        super(tAccessPoint, self).__init__(anytypeobjs_, Text, Private, name, desc, )
        self.router = _cast(bool, router)
        self.clock = _cast(bool, clock)
        self.Server = Server
        if LN is None:
            self.LN = []
        else:
            self.LN = LN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAccessPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAccessPoint.subclass:
            return tAccessPoint.subclass(*args_, **kwargs_)
        else:
            return tAccessPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Server(self): return self.Server
    def set_Server(self, Server): self.Server = Server
    def get_LN(self): return self.LN
    def set_LN(self, LN): self.LN = LN
    def add_LN(self, value): self.LN.append(value)
    def insert_LN_at(self, index, value): self.LN.insert(index, value)
    def replace_LN_at(self, index, value): self.LN[index] = value
    def get_router(self): return self.router
    def set_router(self, router): self.router = router
    def get_clock(self): return self.clock
    def set_clock(self, clock): self.clock = clock
    def hasContent_(self):
        if (
            self.Server is not None or
            self.LN or
            super(tAccessPoint, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAccessPoint', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAccessPoint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAccessPoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAccessPoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAccessPoint'):
        super(tAccessPoint, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tAccessPoint')
        if self.router and 'router' not in already_processed:
            already_processed.add('router')
            outfile.write(' router="%s"' % self.gds_format_boolean(self.router, input_name='router'))
        if self.clock and 'clock' not in already_processed:
            already_processed.add('clock')
            outfile.write(' clock="%s"' % self.gds_format_boolean(self.clock, input_name='clock'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAccessPoint', fromsubclass_=False, pretty_print=True):
        super(tAccessPoint, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Server is not None:
            self.Server.export(outfile, level, namespace_, name_='Server', pretty_print=pretty_print)
        for LN_ in self.LN:
            LN_.export(outfile, level, namespace_, name_='LN', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('router', node)
        if value is not None and 'router' not in already_processed:
            already_processed.add('router')
            if value in ('true', '1'):
                self.router = True
            elif value in ('false', '0'):
                self.router = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('clock', node)
        if value is not None and 'clock' not in already_processed:
            already_processed.add('clock')
            if value in ('true', '1'):
                self.clock = True
            elif value in ('false', '0'):
                self.clock = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tAccessPoint, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Server':
            obj_ = tServer.factory()
            obj_.build(child_)
            self.Server = obj_
            obj_.original_tagname_ = 'Server'
        elif nodeName_ == 'LN':
            obj_ = tLN.factory()
            obj_.build(child_)
            self.LN.append(obj_)
            obj_.original_tagname_ = 'LN'
        super(tAccessPoint, self).buildChildren(child_, node, nodeName_, True)
# end class tAccessPoint


class tServer(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, timeout=30, Authentication=None, LDevice=None, Association=None):
        self.original_tagname_ = None
        super(tServer, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.timeout = _cast(int, timeout)
        self.Authentication = Authentication
        if LDevice is None:
            self.LDevice = []
        else:
            self.LDevice = LDevice
        if Association is None:
            self.Association = []
        else:
            self.Association = Association
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServer.subclass:
            return tServer.subclass(*args_, **kwargs_)
        else:
            return tServer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Authentication(self): return self.Authentication
    def set_Authentication(self, Authentication): self.Authentication = Authentication
    def get_LDevice(self): return self.LDevice
    def set_LDevice(self, LDevice): self.LDevice = LDevice
    def add_LDevice(self, value): self.LDevice.append(value)
    def insert_LDevice_at(self, index, value): self.LDevice.insert(index, value)
    def replace_LDevice_at(self, index, value): self.LDevice[index] = value
    def get_Association(self): return self.Association
    def set_Association(self, Association): self.Association = Association
    def add_Association(self, value): self.Association.append(value)
    def insert_Association_at(self, index, value): self.Association.insert(index, value)
    def replace_Association_at(self, index, value): self.Association[index] = value
    def get_timeout(self): return self.timeout
    def set_timeout(self, timeout): self.timeout = timeout
    def hasContent_(self):
        if (
            self.Authentication is not None or
            self.LDevice or
            self.Association or
            super(tServer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServer', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServer'):
        super(tServer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tServer')
        if self.timeout != 30 and 'timeout' not in already_processed:
            already_processed.add('timeout')
            outfile.write(' timeout="%s"' % self.gds_format_integer(self.timeout, input_name='timeout'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServer', fromsubclass_=False, pretty_print=True):
        super(tServer, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Authentication is not None:
            self.Authentication.export(outfile, level, namespace_, name_='Authentication', pretty_print=pretty_print)
        for LDevice_ in self.LDevice:
            LDevice_.export(outfile, level, namespace_, name_='LDevice', pretty_print=pretty_print)
        for Association_ in self.Association:
            Association_.export(outfile, level, namespace_, name_='Association', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeout', node)
        if value is not None and 'timeout' not in already_processed:
            already_processed.add('timeout')
            try:
                self.timeout = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tServer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Authentication':
            obj_ = AuthenticationType.factory()
            obj_.build(child_)
            self.Authentication = obj_
            obj_.original_tagname_ = 'Authentication'
        elif nodeName_ == 'LDevice':
            obj_ = tLDevice.factory()
            obj_.build(child_)
            self.LDevice.append(obj_)
            obj_.original_tagname_ = 'LDevice'
        elif nodeName_ == 'Association':
            obj_ = tAssociation.factory()
            obj_.build(child_)
            self.Association.append(obj_)
            obj_.original_tagname_ = 'Association'
        super(tServer, self).buildChildren(child_, node, nodeName_, True)
# end class tServer


class tLDevice(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, inst=None, ldName=None, LN0=None, LN=None, AccessControl=None):
        self.original_tagname_ = None
        super(tLDevice, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.inst = _cast(None, inst)
        self.ldName = _cast(None, ldName)
        self.LN0 = LN0
        if LN is None:
            self.LN = []
        else:
            self.LN = LN
        self.AccessControl = AccessControl
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLDevice.subclass:
            return tLDevice.subclass(*args_, **kwargs_)
        else:
            return tLDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LN0(self): return self.LN0
    def set_LN0(self, LN0): self.LN0 = LN0
    def get_LN(self): return self.LN
    def set_LN(self, LN): self.LN = LN
    def add_LN(self, value): self.LN.append(value)
    def insert_LN_at(self, index, value): self.LN.insert(index, value)
    def replace_LN_at(self, index, value): self.LN[index] = value
    def get_AccessControl(self): return self.AccessControl
    def set_AccessControl(self, AccessControl): self.AccessControl = AccessControl
    def get_inst(self): return self.inst
    def set_inst(self, inst): self.inst = inst
    def get_ldName(self): return self.ldName
    def set_ldName(self, ldName): self.ldName = ldName
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def validate_tRestrLdName(self, value):
        # Validate type tRestrLdName, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 64:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tRestrLdName' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tRestrLdName_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tRestrLdName_patterns_, ))
    validate_tRestrLdName_patterns_ = [['^\\p{L}[\\d,\\p{L}]*$']]
    def hasContent_(self):
        if (
            self.LN0 is not None or
            self.LN or
            self.AccessControl is not None or
            super(tLDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLDevice', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLDevice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLDevice'):
        super(tLDevice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLDevice')
        if self.inst is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            outfile.write(' inst=%s' % (quote_attrib(self.inst), ))
        if self.ldName is not None and 'ldName' not in already_processed:
            already_processed.add('ldName')
            outfile.write(' ldName=%s' % (quote_attrib(self.ldName), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLDevice', fromsubclass_=False, pretty_print=True):
        super(tLDevice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LN0 is not None:
            self.LN0.export(outfile, level, namespace_, name_='LN0', pretty_print=pretty_print)
        for LN_ in self.LN:
            LN_.export(outfile, level, namespace_, name_='LN', pretty_print=pretty_print)
        if self.AccessControl is not None:
            self.AccessControl.export(outfile, level, namespace_, name_='AccessControl', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('inst', node)
        if value is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            self.inst = value
            self.validate_tName(self.inst)    # validate type tName
        value = find_attr_value_('ldName', node)
        if value is not None and 'ldName' not in already_processed:
            already_processed.add('ldName')
            self.ldName = value
            self.validate_tRestrLdName(self.ldName)    # validate type tRestrLdName
        super(tLDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LN0':
            obj_ = LN0.factory()
            obj_.build(child_)
            self.LN0 = obj_
            obj_.original_tagname_ = 'LN0'
        elif nodeName_ == 'LN':
            obj_ = tLN.factory()
            obj_.build(child_)
            self.LN.append(obj_)
            obj_.original_tagname_ = 'LN'
        elif nodeName_ == 'AccessControl':
            obj_ = tAccessControl.factory()
            obj_.build(child_)
            self.AccessControl = obj_
            obj_.original_tagname_ = 'AccessControl'
        super(tLDevice, self).buildChildren(child_, node, nodeName_, True)
# end class tLDevice


class tAccessControl(tAnyContentFromOtherNamespace):
    subclass = None
    superclass = tAnyContentFromOtherNamespace
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(tAccessControl, self).__init__(anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAccessControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAccessControl.subclass:
            return tAccessControl.subclass(*args_, **kwargs_)
        else:
            return tAccessControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tAccessControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAccessControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAccessControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAccessControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAccessControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAccessControl'):
        super(tAccessControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tAccessControl')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAccessControl', fromsubclass_=False, pretty_print=True):
        super(tAccessControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tAccessControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(tAccessControl, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tAccessControl


class tAssociation(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, kind=None, associationID=None, iedName=None, ldInst=None, prefix='', lnClass=None, lnInst=None):
        self.original_tagname_ = None
        self.kind = _cast(None, kind)
        self.associationID = _cast(None, associationID)
        self.iedName = _cast(None, iedName)
        self.ldInst = _cast(None, ldInst)
        self.prefix = _cast(None, prefix)
        self.lnClass = _cast(None, lnClass)
        self.lnInst = _cast(None, lnInst)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAssociation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAssociation.subclass:
            return tAssociation.subclass(*args_, **kwargs_)
        else:
            return tAssociation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_associationID(self): return self.associationID
    def set_associationID(self, associationID): self.associationID = associationID
    def get_iedName(self): return self.iedName
    def set_iedName(self, iedName): self.iedName = iedName
    def get_ldInst(self): return self.ldInst
    def set_ldInst(self, ldInst): self.ldInst = ldInst
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_lnInst(self): return self.lnInst
    def set_lnInst(self, lnInst): self.lnInst = lnInst
    def validate_tAssociationKindEnum(self, value):
        # Validate type tAssociationKindEnum, a restriction on xs:token.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['pre-established', 'predefined']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tAssociationKindEnum' % {"value" : value.encode("utf-8")} )
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAssociation', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAssociation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAssociation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAssociation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAssociation'):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
        if self.associationID is not None and 'associationID' not in already_processed:
            already_processed.add('associationID')
            outfile.write(' associationID=%s' % (quote_attrib(self.associationID), ))
        if self.iedName is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            outfile.write(' iedName=%s' % (quote_attrib(self.iedName), ))
        if self.ldInst is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            outfile.write(' ldInst=%s' % (quote_attrib(self.ldInst), ))
        if self.prefix != "" and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (quote_attrib(self.prefix), ))
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.lnInst is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            outfile.write(' lnInst=%s' % (quote_attrib(self.lnInst), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAssociation', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.add('kind')
            self.kind = value
            self.kind = ' '.join(self.kind.split())
            self.validate_tAssociationKindEnum(self.kind)    # validate type tAssociationKindEnum
        value = find_attr_value_('associationID', node)
        if value is not None and 'associationID' not in already_processed:
            already_processed.add('associationID')
            self.associationID = value
            self.validate_tName(self.associationID)    # validate type tName
        value = find_attr_value_('iedName', node)
        if value is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            self.iedName = value
            self.validate_tName(self.iedName)    # validate type tName
        value = find_attr_value_('ldInst', node)
        if value is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            self.ldInst = value
            self.validate_tName(self.ldInst)    # validate type tName
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_tAnyName(self.prefix)    # validate type tAnyName
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('lnInst', node)
        if value is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            self.lnInst = value
            self.validate_tAnyName(self.lnInst)    # validate type tAnyName
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tAssociation


class tAnyLN(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, lnType=None, DataSet=None, ReportControl=None, LogControl=None, DOI=None, Inputs=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tAnyLN, self).__init__(anytypeobjs_, Text, Private, desc, extensiontype_, )
        self.lnType = _cast(None, lnType)
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if ReportControl is None:
            self.ReportControl = []
        else:
            self.ReportControl = ReportControl
        if LogControl is None:
            self.LogControl = []
        else:
            self.LogControl = LogControl
        if DOI is None:
            self.DOI = []
        else:
            self.DOI = DOI
        self.Inputs = Inputs
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAnyLN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAnyLN.subclass:
            return tAnyLN.subclass(*args_, **kwargs_)
        else:
            return tAnyLN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_ReportControl(self): return self.ReportControl
    def set_ReportControl(self, ReportControl): self.ReportControl = ReportControl
    def add_ReportControl(self, value): self.ReportControl.append(value)
    def insert_ReportControl_at(self, index, value): self.ReportControl.insert(index, value)
    def replace_ReportControl_at(self, index, value): self.ReportControl[index] = value
    def get_LogControl(self): return self.LogControl
    def set_LogControl(self, LogControl): self.LogControl = LogControl
    def add_LogControl(self, value): self.LogControl.append(value)
    def insert_LogControl_at(self, index, value): self.LogControl.insert(index, value)
    def replace_LogControl_at(self, index, value): self.LogControl[index] = value
    def get_DOI(self): return self.DOI
    def set_DOI(self, DOI): self.DOI = DOI
    def add_DOI(self, value): self.DOI.append(value)
    def insert_DOI_at(self, index, value): self.DOI.insert(index, value)
    def replace_DOI_at(self, index, value): self.DOI[index] = value
    def get_Inputs(self): return self.Inputs
    def set_Inputs(self, Inputs): self.Inputs = Inputs
    def get_lnType(self): return self.lnType
    def set_lnType(self, lnType): self.lnType = lnType
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            self.DataSet or
            self.ReportControl or
            self.LogControl or
            self.DOI or
            self.Inputs is not None or
            super(tAnyLN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAnyLN', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAnyLN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAnyLN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAnyLN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAnyLN'):
        super(tAnyLN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tAnyLN')
        if self.lnType is not None and 'lnType' not in already_processed:
            already_processed.add('lnType')
            outfile.write(' lnType=%s' % (quote_attrib(self.lnType), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAnyLN', fromsubclass_=False, pretty_print=True):
        super(tAnyLN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_, name_='DataSet', pretty_print=pretty_print)
        for ReportControl_ in self.ReportControl:
            ReportControl_.export(outfile, level, namespace_, name_='ReportControl', pretty_print=pretty_print)
        for LogControl_ in self.LogControl:
            LogControl_.export(outfile, level, namespace_, name_='LogControl', pretty_print=pretty_print)
        for DOI_ in self.DOI:
            DOI_.export(outfile, level, namespace_, name_='DOI', pretty_print=pretty_print)
        if self.Inputs is not None:
            self.Inputs.export(outfile, level, namespace_, name_='Inputs', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lnType', node)
        if value is not None and 'lnType' not in already_processed:
            already_processed.add('lnType')
            self.lnType = value
            self.validate_tName(self.lnType)    # validate type tName
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tAnyLN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            obj_ = tDataSet.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'ReportControl':
            obj_ = tReportControl.factory()
            obj_.build(child_)
            self.ReportControl.append(obj_)
            obj_.original_tagname_ = 'ReportControl'
        elif nodeName_ == 'LogControl':
            obj_ = tLogControl.factory()
            obj_.build(child_)
            self.LogControl.append(obj_)
            obj_.original_tagname_ = 'LogControl'
        elif nodeName_ == 'DOI':
            obj_ = tDOI.factory()
            obj_.build(child_)
            self.DOI.append(obj_)
            obj_.original_tagname_ = 'DOI'
        elif nodeName_ == 'Inputs':
            obj_ = tInputs.factory()
            obj_.build(child_)
            self.Inputs = obj_
            obj_.original_tagname_ = 'Inputs'
        super(tAnyLN, self).buildChildren(child_, node, nodeName_, True)
# end class tAnyLN


class tLN(tAnyLN):
    subclass = None
    superclass = tAnyLN
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, lnType=None, DataSet=None, ReportControl=None, LogControl=None, DOI=None, Inputs=None, lnClass=None, inst=None, prefix=''):
        self.original_tagname_ = None
        super(tLN, self).__init__(anytypeobjs_, Text, Private, desc, lnType, DataSet, ReportControl, LogControl, DOI, Inputs, )
        self.lnClass = _cast(None, lnClass)
        self.inst = _cast(int, inst)
        self.prefix = _cast(None, prefix)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLN.subclass:
            return tLN.subclass(*args_, **kwargs_)
        else:
            return tLN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_inst(self): return self.inst
    def set_inst(self, inst): self.inst = inst
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            super(tLN, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLN', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLN'):
        super(tLN, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLN')
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.inst is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            outfile.write(' inst="%s"' % self.gds_format_integer(self.inst, input_name='inst'))
        if self.prefix != "" and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (quote_attrib(self.prefix), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLN', fromsubclass_=False, pretty_print=True):
        super(tLN, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('inst', node)
        if value is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            try:
                self.inst = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_tAnyName(self.prefix)    # validate type tAnyName
        super(tLN, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tLN, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tLN


class tLN0(tAnyLN):
    subclass = None
    superclass = tAnyLN
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, lnType=None, DataSet=None, ReportControl=None, LogControl=None, DOI=None, Inputs=None, lnClass='LLN0', inst='', GSEControl=None, SampledValueControl=None, SettingControl=None, SCLControl=None, Log=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tLN0, self).__init__(anytypeobjs_, Text, Private, desc, lnType, DataSet, ReportControl, LogControl, DOI, Inputs, extensiontype_, )
        self.lnClass = _cast(None, lnClass)
        self.inst = _cast(None, inst)
        if GSEControl is None:
            self.GSEControl = []
        else:
            self.GSEControl = GSEControl
        if SampledValueControl is None:
            self.SampledValueControl = []
        else:
            self.SampledValueControl = SampledValueControl
        self.SettingControl = SettingControl
        self.SCLControl = SCLControl
        self.Log = Log
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLN0)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLN0.subclass:
            return tLN0.subclass(*args_, **kwargs_)
        else:
            return tLN0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GSEControl(self): return self.GSEControl
    def set_GSEControl(self, GSEControl): self.GSEControl = GSEControl
    def add_GSEControl(self, value): self.GSEControl.append(value)
    def insert_GSEControl_at(self, index, value): self.GSEControl.insert(index, value)
    def replace_GSEControl_at(self, index, value): self.GSEControl[index] = value
    def get_SampledValueControl(self): return self.SampledValueControl
    def set_SampledValueControl(self, SampledValueControl): self.SampledValueControl = SampledValueControl
    def add_SampledValueControl(self, value): self.SampledValueControl.append(value)
    def insert_SampledValueControl_at(self, index, value): self.SampledValueControl.insert(index, value)
    def replace_SampledValueControl_at(self, index, value): self.SampledValueControl[index] = value
    def get_SettingControl(self): return self.SettingControl
    def set_SettingControl(self, SettingControl): self.SettingControl = SettingControl
    def get_SCLControl(self): return self.SCLControl
    def set_SCLControl(self, SCLControl): self.SCLControl = SCLControl
    def get_Log(self): return self.Log
    def set_Log(self, Log): self.Log = Log
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_inst(self): return self.inst
    def set_inst(self, inst): self.inst = inst
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.GSEControl or
            self.SampledValueControl or
            self.SettingControl is not None or
            self.SCLControl is not None or
            self.Log is not None or
            super(tLN0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLN0', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLN0')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLN0')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLN0', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLN0'):
        super(tLN0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLN0')
        if self.lnClass != "LLN0" and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.inst != "" and 'inst' not in already_processed:
            already_processed.add('inst')
            outfile.write(' inst=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.inst), input_name='inst')), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLN0', fromsubclass_=False, pretty_print=True):
        super(tLN0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GSEControl_ in self.GSEControl:
            GSEControl_.export(outfile, level, namespace_, name_='GSEControl', pretty_print=pretty_print)
        for SampledValueControl_ in self.SampledValueControl:
            SampledValueControl_.export(outfile, level, namespace_, name_='SampledValueControl', pretty_print=pretty_print)
        if self.SettingControl is not None:
            self.SettingControl.export(outfile, level, namespace_, name_='SettingControl', pretty_print=pretty_print)
        if self.SCLControl is not None:
            self.SCLControl.export(outfile, level, namespace_, name_='SCLControl', pretty_print=pretty_print)
        if self.Log is not None:
            self.Log.export(outfile, level, namespace_, name_='Log', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('inst', node)
        if value is not None and 'inst' not in already_processed:
            already_processed.add('inst')
            self.inst = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tLN0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GSEControl':
            obj_ = tGSEControl.factory()
            obj_.build(child_)
            self.GSEControl.append(obj_)
            obj_.original_tagname_ = 'GSEControl'
        elif nodeName_ == 'SampledValueControl':
            obj_ = tSampledValueControl.factory()
            obj_.build(child_)
            self.SampledValueControl.append(obj_)
            obj_.original_tagname_ = 'SampledValueControl'
        elif nodeName_ == 'SettingControl':
            obj_ = tSettingControl.factory()
            obj_.build(child_)
            self.SettingControl = obj_
            obj_.original_tagname_ = 'SettingControl'
        elif nodeName_ == 'SCLControl':
            obj_ = tSCLControl.factory()
            obj_.build(child_)
            self.SCLControl = obj_
            obj_.original_tagname_ = 'SCLControl'
        elif nodeName_ == 'Log':
            obj_ = tLog.factory()
            obj_.build(child_)
            self.Log = obj_
            obj_.original_tagname_ = 'Log'
        super(tLN0, self).buildChildren(child_, node, nodeName_, True)
# end class tLN0


class tDataSet(tNaming):
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, FCDA=None):
        self.original_tagname_ = None
        super(tDataSet, self).__init__(anytypeobjs_, Text, Private, name, desc, )
        if FCDA is None:
            self.FCDA = []
        else:
            self.FCDA = FCDA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDataSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDataSet.subclass:
            return tDataSet.subclass(*args_, **kwargs_)
        else:
            return tDataSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FCDA(self): return self.FCDA
    def set_FCDA(self, FCDA): self.FCDA = FCDA
    def add_FCDA(self, value): self.FCDA.append(value)
    def insert_FCDA_at(self, index, value): self.FCDA.insert(index, value)
    def replace_FCDA_at(self, index, value): self.FCDA[index] = value
    def hasContent_(self):
        if (
            self.FCDA or
            super(tDataSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDataSet', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDataSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDataSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDataSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDataSet'):
        super(tDataSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDataSet')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDataSet', fromsubclass_=False, pretty_print=True):
        super(tDataSet, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FCDA_ in self.FCDA:
            FCDA_.export(outfile, level, namespace_, name_='FCDA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tDataSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FCDA':
            obj_ = tFCDA.factory()
            obj_.build(child_)
            self.FCDA.append(obj_)
            obj_.original_tagname_ = 'FCDA'
        super(tDataSet, self).buildChildren(child_, node, nodeName_, True)
# end class tDataSet


class tFCDA(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ldInst=None, prefix='', lnClass=None, lnInst=None, doName=None, daName=None, fc=None):
        self.original_tagname_ = None
        self.ldInst = _cast(None, ldInst)
        self.prefix = _cast(None, prefix)
        self.lnClass = _cast(None, lnClass)
        self.lnInst = _cast(None, lnInst)
        self.doName = _cast(None, doName)
        self.daName = _cast(None, daName)
        self.fc = _cast(None, fc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tFCDA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tFCDA.subclass:
            return tFCDA.subclass(*args_, **kwargs_)
        else:
            return tFCDA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ldInst(self): return self.ldInst
    def set_ldInst(self, ldInst): self.ldInst = ldInst
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_lnInst(self): return self.lnInst
    def set_lnInst(self, lnInst): self.lnInst = lnInst
    def get_doName(self): return self.doName
    def set_doName(self, doName): self.doName = doName
    def get_daName(self): return self.daName
    def set_daName(self, daName): self.daName = daName
    def get_fc(self): return self.fc
    def set_fc(self, fc): self.fc = fc
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def validate_tFCEnum(self, value):
        # Validate type tFCEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ST', 'MX', 'CO', 'SP', 'SG', 'SE', 'SV', 'CF', 'DC', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tFCEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tFCDA', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tFCDA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tFCDA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tFCDA', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tFCDA'):
        if self.ldInst is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            outfile.write(' ldInst=%s' % (quote_attrib(self.ldInst), ))
        if self.prefix != "" and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (quote_attrib(self.prefix), ))
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.lnInst is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            outfile.write(' lnInst=%s' % (quote_attrib(self.lnInst), ))
        if self.doName is not None and 'doName' not in already_processed:
            already_processed.add('doName')
            outfile.write(' doName=%s' % (quote_attrib(self.doName), ))
        if self.daName is not None and 'daName' not in already_processed:
            already_processed.add('daName')
            outfile.write(' daName=%s' % (quote_attrib(self.daName), ))
        if self.fc is not None and 'fc' not in already_processed:
            already_processed.add('fc')
            outfile.write(' fc=%s' % (quote_attrib(self.fc), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tFCDA', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ldInst', node)
        if value is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            self.ldInst = value
            self.validate_tName(self.ldInst)    # validate type tName
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_tAnyName(self.prefix)    # validate type tAnyName
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('lnInst', node)
        if value is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            self.lnInst = value
            self.validate_tName(self.lnInst)    # validate type tName
        value = find_attr_value_('doName', node)
        if value is not None and 'doName' not in already_processed:
            already_processed.add('doName')
            self.doName = value
            self.validate_tName(self.doName)    # validate type tName
        value = find_attr_value_('daName', node)
        if value is not None and 'daName' not in already_processed:
            already_processed.add('daName')
            self.daName = value
            self.validate_tName(self.daName)    # validate type tName
        value = find_attr_value_('fc', node)
        if value is not None and 'fc' not in already_processed:
            already_processed.add('fc')
            self.fc = value
            self.validate_tFCEnum(self.fc)    # validate type tFCEnum
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tFCDA


class tControl(tNaming):
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tControl, self).__init__(anytypeobjs_, Text, Private, name, desc, extensiontype_, )
        self.datSet = _cast(None, datSet)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tControl.subclass:
            return tControl.subclass(*args_, **kwargs_)
        else:
            return tControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_datSet(self): return self.datSet
    def set_datSet(self, datSet): self.datSet = datSet
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tControl'):
        super(tControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tControl')
        if self.datSet is not None and 'datSet' not in already_processed:
            already_processed.add('datSet')
            outfile.write(' datSet=%s' % (quote_attrib(self.datSet), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tControl', fromsubclass_=False, pretty_print=True):
        super(tControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('datSet', node)
        if value is not None and 'datSet' not in already_processed:
            already_processed.add('datSet')
            self.datSet = value
            self.validate_tName(self.datSet)    # validate type tName
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tControl, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tControl


class tControlWithTriggerOpt(tControl):
    subclass = None
    superclass = tControl
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, intgPd=0, TrgOps=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tControlWithTriggerOpt, self).__init__(anytypeobjs_, Text, Private, name, desc, datSet, extensiontype_, )
        self.intgPd = _cast(int, intgPd)
        self.TrgOps = TrgOps
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tControlWithTriggerOpt)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tControlWithTriggerOpt.subclass:
            return tControlWithTriggerOpt.subclass(*args_, **kwargs_)
        else:
            return tControlWithTriggerOpt(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TrgOps(self): return self.TrgOps
    def set_TrgOps(self, TrgOps): self.TrgOps = TrgOps
    def get_intgPd(self): return self.intgPd
    def set_intgPd(self, intgPd): self.intgPd = intgPd
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.TrgOps is not None or
            super(tControlWithTriggerOpt, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tControlWithTriggerOpt', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tControlWithTriggerOpt')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tControlWithTriggerOpt')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tControlWithTriggerOpt', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tControlWithTriggerOpt'):
        super(tControlWithTriggerOpt, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tControlWithTriggerOpt')
        if self.intgPd != 0 and 'intgPd' not in already_processed:
            already_processed.add('intgPd')
            outfile.write(' intgPd="%s"' % self.gds_format_integer(self.intgPd, input_name='intgPd'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tControlWithTriggerOpt', fromsubclass_=False, pretty_print=True):
        super(tControlWithTriggerOpt, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TrgOps is not None:
            self.TrgOps.export(outfile, level, namespace_, name_='TrgOps', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('intgPd', node)
        if value is not None and 'intgPd' not in already_processed:
            already_processed.add('intgPd')
            try:
                self.intgPd = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tControlWithTriggerOpt, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TrgOps':
            obj_ = tTrgOps.factory()
            obj_.build(child_)
            self.TrgOps = obj_
            obj_.original_tagname_ = 'TrgOps'
        super(tControlWithTriggerOpt, self).buildChildren(child_, node, nodeName_, True)
# end class tControlWithTriggerOpt


class tTrgOps(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dchg=False, qchg=False, dupd=False, period=False, gi=True):
        self.original_tagname_ = None
        self.dchg = _cast(bool, dchg)
        self.qchg = _cast(bool, qchg)
        self.dupd = _cast(bool, dupd)
        self.period = _cast(bool, period)
        self.gi = _cast(bool, gi)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tTrgOps)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tTrgOps.subclass:
            return tTrgOps.subclass(*args_, **kwargs_)
        else:
            return tTrgOps(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dchg(self): return self.dchg
    def set_dchg(self, dchg): self.dchg = dchg
    def get_qchg(self): return self.qchg
    def set_qchg(self, qchg): self.qchg = qchg
    def get_dupd(self): return self.dupd
    def set_dupd(self, dupd): self.dupd = dupd
    def get_period(self): return self.period
    def set_period(self, period): self.period = period
    def get_gi(self): return self.gi
    def set_gi(self, gi): self.gi = gi
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tTrgOps', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tTrgOps')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tTrgOps')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tTrgOps', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tTrgOps'):
        if self.dchg and 'dchg' not in already_processed:
            already_processed.add('dchg')
            outfile.write(' dchg="%s"' % self.gds_format_boolean(self.dchg, input_name='dchg'))
        if self.qchg and 'qchg' not in already_processed:
            already_processed.add('qchg')
            outfile.write(' qchg="%s"' % self.gds_format_boolean(self.qchg, input_name='qchg'))
        if self.dupd and 'dupd' not in already_processed:
            already_processed.add('dupd')
            outfile.write(' dupd="%s"' % self.gds_format_boolean(self.dupd, input_name='dupd'))
        if self.period and 'period' not in already_processed:
            already_processed.add('period')
            outfile.write(' period="%s"' % self.gds_format_boolean(self.period, input_name='period'))
        if not self.gi and 'gi' not in already_processed:
            already_processed.add('gi')
            outfile.write(' gi="%s"' % self.gds_format_boolean(self.gi, input_name='gi'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tTrgOps', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dchg', node)
        if value is not None and 'dchg' not in already_processed:
            already_processed.add('dchg')
            if value in ('true', '1'):
                self.dchg = True
            elif value in ('false', '0'):
                self.dchg = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('qchg', node)
        if value is not None and 'qchg' not in already_processed:
            already_processed.add('qchg')
            if value in ('true', '1'):
                self.qchg = True
            elif value in ('false', '0'):
                self.qchg = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dupd', node)
        if value is not None and 'dupd' not in already_processed:
            already_processed.add('dupd')
            if value in ('true', '1'):
                self.dupd = True
            elif value in ('false', '0'):
                self.dupd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('period', node)
        if value is not None and 'period' not in already_processed:
            already_processed.add('period')
            if value in ('true', '1'):
                self.period = True
            elif value in ('false', '0'):
                self.period = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('gi', node)
        if value is not None and 'gi' not in already_processed:
            already_processed.add('gi')
            if value in ('true', '1'):
                self.gi = True
            elif value in ('false', '0'):
                self.gi = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tTrgOps


class tReportControl(tControlWithTriggerOpt):
    subclass = None
    superclass = tControlWithTriggerOpt
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, intgPd=0, TrgOps=None, rptID=None, confRev=None, buffered=False, bufTime=0, OptFields=None, RptEnabled=None):
        self.original_tagname_ = None
        super(tReportControl, self).__init__(anytypeobjs_, Text, Private, name, desc, datSet, intgPd, TrgOps, )
        self.rptID = _cast(None, rptID)
        self.confRev = _cast(int, confRev)
        self.buffered = _cast(bool, buffered)
        self.bufTime = _cast(int, bufTime)
        self.OptFields = OptFields
        self.RptEnabled = RptEnabled
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tReportControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tReportControl.subclass:
            return tReportControl.subclass(*args_, **kwargs_)
        else:
            return tReportControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OptFields(self): return self.OptFields
    def set_OptFields(self, OptFields): self.OptFields = OptFields
    def get_RptEnabled(self): return self.RptEnabled
    def set_RptEnabled(self, RptEnabled): self.RptEnabled = RptEnabled
    def get_rptID(self): return self.rptID
    def set_rptID(self, rptID): self.rptID = rptID
    def get_confRev(self): return self.confRev
    def set_confRev(self, confRev): self.confRev = confRev
    def get_buffered(self): return self.buffered
    def set_buffered(self, buffered): self.buffered = buffered
    def get_bufTime(self): return self.bufTime
    def set_bufTime(self, bufTime): self.bufTime = bufTime
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.OptFields is not None or
            self.RptEnabled is not None or
            super(tReportControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tReportControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tReportControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tReportControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tReportControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tReportControl'):
        super(tReportControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tReportControl')
        if self.rptID is not None and 'rptID' not in already_processed:
            already_processed.add('rptID')
            outfile.write(' rptID=%s' % (quote_attrib(self.rptID), ))
        if self.confRev is not None and 'confRev' not in already_processed:
            already_processed.add('confRev')
            outfile.write(' confRev="%s"' % self.gds_format_integer(self.confRev, input_name='confRev'))
        if self.buffered and 'buffered' not in already_processed:
            already_processed.add('buffered')
            outfile.write(' buffered="%s"' % self.gds_format_boolean(self.buffered, input_name='buffered'))
        if self.bufTime != 0 and 'bufTime' not in already_processed:
            already_processed.add('bufTime')
            outfile.write(' bufTime="%s"' % self.gds_format_integer(self.bufTime, input_name='bufTime'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tReportControl', fromsubclass_=False, pretty_print=True):
        super(tReportControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OptFields is not None:
            self.OptFields.export(outfile, level, namespace_, name_='OptFields', pretty_print=pretty_print)
        if self.RptEnabled is not None:
            self.RptEnabled.export(outfile, level, namespace_, name_='RptEnabled', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rptID', node)
        if value is not None and 'rptID' not in already_processed:
            already_processed.add('rptID')
            self.rptID = value
            self.validate_tAnyName(self.rptID)    # validate type tAnyName
        value = find_attr_value_('confRev', node)
        if value is not None and 'confRev' not in already_processed:
            already_processed.add('confRev')
            try:
                self.confRev = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('buffered', node)
        if value is not None and 'buffered' not in already_processed:
            already_processed.add('buffered')
            if value in ('true', '1'):
                self.buffered = True
            elif value in ('false', '0'):
                self.buffered = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bufTime', node)
        if value is not None and 'bufTime' not in already_processed:
            already_processed.add('bufTime')
            try:
                self.bufTime = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tReportControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OptFields':
            obj_ = OptFieldsType.factory()
            obj_.build(child_)
            self.OptFields = obj_
            obj_.original_tagname_ = 'OptFields'
        elif nodeName_ == 'RptEnabled':
            obj_ = tRptEnabled.factory()
            obj_.build(child_)
            self.RptEnabled = obj_
            obj_.original_tagname_ = 'RptEnabled'
        super(tReportControl, self).buildChildren(child_, node, nodeName_, True)
# end class tReportControl


class tRptEnabled(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, max=1, ClientLN=None):
        self.original_tagname_ = None
        super(tRptEnabled, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.max = _cast(int, max)
        if ClientLN is None:
            self.ClientLN = []
        else:
            self.ClientLN = ClientLN
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tRptEnabled)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tRptEnabled.subclass:
            return tRptEnabled.subclass(*args_, **kwargs_)
        else:
            return tRptEnabled(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ClientLN(self): return self.ClientLN
    def set_ClientLN(self, ClientLN): self.ClientLN = ClientLN
    def add_ClientLN(self, value): self.ClientLN.append(value)
    def insert_ClientLN_at(self, index, value): self.ClientLN.insert(index, value)
    def replace_ClientLN_at(self, index, value): self.ClientLN[index] = value
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def hasContent_(self):
        if (
            self.ClientLN or
            super(tRptEnabled, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tRptEnabled', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tRptEnabled')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tRptEnabled')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tRptEnabled', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tRptEnabled'):
        super(tRptEnabled, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tRptEnabled')
        if self.max != 1 and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_integer(self.max, input_name='max'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tRptEnabled', fromsubclass_=False, pretty_print=True):
        super(tRptEnabled, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ClientLN_ in self.ClientLN:
            ClientLN_.export(outfile, level, namespace_, name_='ClientLN', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tRptEnabled, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ClientLN':
            obj_ = tClientLN.factory()
            obj_.build(child_)
            self.ClientLN.append(obj_)
            obj_.original_tagname_ = 'ClientLN'
        super(tRptEnabled, self).buildChildren(child_, node, nodeName_, True)
# end class tRptEnabled


class tClientLN(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, iedName=None, ldInst=None, prefix='', lnClass=None, lnInst=None):
        self.original_tagname_ = None
        self.iedName = _cast(None, iedName)
        self.ldInst = _cast(None, ldInst)
        self.prefix = _cast(None, prefix)
        self.lnClass = _cast(None, lnClass)
        self.lnInst = _cast(None, lnInst)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tClientLN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tClientLN.subclass:
            return tClientLN.subclass(*args_, **kwargs_)
        else:
            return tClientLN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_iedName(self): return self.iedName
    def set_iedName(self, iedName): self.iedName = iedName
    def get_ldInst(self): return self.ldInst
    def set_ldInst(self, ldInst): self.ldInst = ldInst
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_lnInst(self): return self.lnInst
    def set_lnInst(self, lnInst): self.lnInst = lnInst
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tClientLN', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tClientLN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tClientLN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tClientLN', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tClientLN'):
        if self.iedName is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            outfile.write(' iedName=%s' % (quote_attrib(self.iedName), ))
        if self.ldInst is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            outfile.write(' ldInst=%s' % (quote_attrib(self.ldInst), ))
        if self.prefix != "" and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (quote_attrib(self.prefix), ))
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.lnInst is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            outfile.write(' lnInst=%s' % (quote_attrib(self.lnInst), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tClientLN', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iedName', node)
        if value is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            self.iedName = value
            self.validate_tName(self.iedName)    # validate type tName
        value = find_attr_value_('ldInst', node)
        if value is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            self.ldInst = value
            self.validate_tName(self.ldInst)    # validate type tName
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_tAnyName(self.prefix)    # validate type tAnyName
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('lnInst', node)
        if value is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            self.lnInst = value
            self.validate_tAnyName(self.lnInst)    # validate type tAnyName
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tClientLN


class tLogControl(tControlWithTriggerOpt):
    subclass = None
    superclass = tControlWithTriggerOpt
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, intgPd=0, TrgOps=None, logName=None, logEna=True, reasonCode=True):
        self.original_tagname_ = None
        super(tLogControl, self).__init__(anytypeobjs_, Text, Private, name, desc, datSet, intgPd, TrgOps, )
        self.logName = _cast(None, logName)
        self.logEna = _cast(bool, logEna)
        self.reasonCode = _cast(bool, reasonCode)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLogControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLogControl.subclass:
            return tLogControl.subclass(*args_, **kwargs_)
        else:
            return tLogControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logName(self): return self.logName
    def set_logName(self, logName): self.logName = logName
    def get_logEna(self): return self.logEna
    def set_logEna(self, logEna): self.logEna = logEna
    def get_reasonCode(self): return self.reasonCode
    def set_reasonCode(self, reasonCode): self.reasonCode = reasonCode
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tLogControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLogControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLogControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLogControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLogControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLogControl'):
        super(tLogControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLogControl')
        if self.logName is not None and 'logName' not in already_processed:
            already_processed.add('logName')
            outfile.write(' logName=%s' % (quote_attrib(self.logName), ))
        if not self.logEna and 'logEna' not in already_processed:
            already_processed.add('logEna')
            outfile.write(' logEna="%s"' % self.gds_format_boolean(self.logEna, input_name='logEna'))
        if not self.reasonCode and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            outfile.write(' reasonCode="%s"' % self.gds_format_boolean(self.reasonCode, input_name='reasonCode'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLogControl', fromsubclass_=False, pretty_print=True):
        super(tLogControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('logName', node)
        if value is not None and 'logName' not in already_processed:
            already_processed.add('logName')
            self.logName = value
            self.validate_tName(self.logName)    # validate type tName
        value = find_attr_value_('logEna', node)
        if value is not None and 'logEna' not in already_processed:
            already_processed.add('logEna')
            if value in ('true', '1'):
                self.logEna = True
            elif value in ('false', '0'):
                self.logEna = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('reasonCode', node)
        if value is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            if value in ('true', '1'):
                self.reasonCode = True
            elif value in ('false', '0'):
                self.reasonCode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tLogControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tLogControl, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tLogControl


class tInputs(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, ExtRef=None):
        self.original_tagname_ = None
        super(tInputs, self).__init__(anytypeobjs_, Text, Private, desc, )
        if ExtRef is None:
            self.ExtRef = []
        else:
            self.ExtRef = ExtRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tInputs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tInputs.subclass:
            return tInputs.subclass(*args_, **kwargs_)
        else:
            return tInputs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExtRef(self): return self.ExtRef
    def set_ExtRef(self, ExtRef): self.ExtRef = ExtRef
    def add_ExtRef(self, value): self.ExtRef.append(value)
    def insert_ExtRef_at(self, index, value): self.ExtRef.insert(index, value)
    def replace_ExtRef_at(self, index, value): self.ExtRef[index] = value
    def hasContent_(self):
        if (
            self.ExtRef or
            super(tInputs, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tInputs', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tInputs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tInputs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tInputs', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tInputs'):
        super(tInputs, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tInputs')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tInputs', fromsubclass_=False, pretty_print=True):
        super(tInputs, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ExtRef_ in self.ExtRef:
            ExtRef_.export(outfile, level, namespace_, name_='ExtRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tInputs, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExtRef':
            obj_ = tExtRef.factory()
            obj_.build(child_)
            self.ExtRef.append(obj_)
            obj_.original_tagname_ = 'ExtRef'
        super(tInputs, self).buildChildren(child_, node, nodeName_, True)
# end class tInputs


class tExtRef(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, daName=None, intAddr=None, iedName=None, ldInst=None, prefix='', lnClass=None, lnInst=None, doName=None):
        self.original_tagname_ = None
        self.daName = _cast(None, daName)
        self.intAddr = _cast(None, intAddr)
        self.iedName = _cast(None, iedName)
        self.ldInst = _cast(None, ldInst)
        self.prefix = _cast(None, prefix)
        self.lnClass = _cast(None, lnClass)
        self.lnInst = _cast(None, lnInst)
        self.doName = _cast(None, doName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tExtRef)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tExtRef.subclass:
            return tExtRef.subclass(*args_, **kwargs_)
        else:
            return tExtRef(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_daName(self): return self.daName
    def set_daName(self, daName): self.daName = daName
    def get_intAddr(self): return self.intAddr
    def set_intAddr(self, intAddr): self.intAddr = intAddr
    def get_iedName(self): return self.iedName
    def set_iedName(self, iedName): self.iedName = iedName
    def get_ldInst(self): return self.ldInst
    def set_ldInst(self, ldInst): self.ldInst = ldInst
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_lnInst(self): return self.lnInst
    def set_lnInst(self, lnInst): self.lnInst = lnInst
    def get_doName(self): return self.doName
    def set_doName(self, doName): self.doName = doName
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tExtRef', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tExtRef')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tExtRef')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tExtRef', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tExtRef'):
        if self.daName is not None and 'daName' not in already_processed:
            already_processed.add('daName')
            outfile.write(' daName=%s' % (quote_attrib(self.daName), ))
        if self.intAddr is not None and 'intAddr' not in already_processed:
            already_processed.add('intAddr')
            outfile.write(' intAddr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.intAddr), input_name='intAddr')), ))
        if self.iedName is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            outfile.write(' iedName=%s' % (quote_attrib(self.iedName), ))
        if self.ldInst is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            outfile.write(' ldInst=%s' % (quote_attrib(self.ldInst), ))
        if self.prefix != "" and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (quote_attrib(self.prefix), ))
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.lnInst is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            outfile.write(' lnInst=%s' % (quote_attrib(self.lnInst), ))
        if self.doName is not None and 'doName' not in already_processed:
            already_processed.add('doName')
            outfile.write(' doName=%s' % (quote_attrib(self.doName), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tExtRef', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('daName', node)
        if value is not None and 'daName' not in already_processed:
            already_processed.add('daName')
            self.daName = value
            self.validate_tName(self.daName)    # validate type tName
        value = find_attr_value_('intAddr', node)
        if value is not None and 'intAddr' not in already_processed:
            already_processed.add('intAddr')
            self.intAddr = value
        value = find_attr_value_('iedName', node)
        if value is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            self.iedName = value
            self.validate_tName(self.iedName)    # validate type tName
        value = find_attr_value_('ldInst', node)
        if value is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            self.ldInst = value
            self.validate_tName(self.ldInst)    # validate type tName
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_tAnyName(self.prefix)    # validate type tAnyName
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('lnInst', node)
        if value is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            self.lnInst = value
            self.validate_tAnyName(self.lnInst)    # validate type tAnyName
        value = find_attr_value_('doName', node)
        if value is not None and 'doName' not in already_processed:
            already_processed.add('doName')
            self.doName = value
            self.validate_tName(self.doName)    # validate type tName
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tExtRef


class tLog(tAnyContentFromOtherNamespace):
    subclass = None
    superclass = tAnyContentFromOtherNamespace
    def __init__(self, anytypeobjs_=None, valueOf_=None, mixedclass_=None, content_=None):
        self.original_tagname_ = None
        super(tLog, self).__init__(anytypeobjs_, valueOf_, mixedclass_, content_, )
        self.valueOf_ = valueOf_
        if mixedclass_ is None:
            self.mixedclass_ = MixedContainer
        else:
            self.mixedclass_ = mixedclass_
        if content_ is None:
            self.content_ = []
        else:
            self.content_ = content_
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLog)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLog.subclass:
            return tLog.subclass(*args_, **kwargs_)
        else:
            return tLog(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tLog, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLog', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLog')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLog')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLog', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLog'):
        super(tLog, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLog')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLog', fromsubclass_=False, pretty_print=True):
        super(tLog, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        if node.text is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', node.text)
            self.content_.append(obj_)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tLog, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if not fromsubclass_ and child_.tail is not None:
            obj_ = self.mixedclass_(MixedContainer.CategoryText,
                MixedContainer.TypeNone, '', child_.tail)
            self.content_.append(obj_)
        super(tLog, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tLog


class tControlWithIEDName(tControl):
    subclass = None
    superclass = tControl
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, confRev=None, IEDName=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tControlWithIEDName, self).__init__(anytypeobjs_, Text, Private, name, desc, datSet, extensiontype_, )
        self.confRev = _cast(int, confRev)
        if IEDName is None:
            self.IEDName = []
        else:
            self.IEDName = IEDName
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tControlWithIEDName)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tControlWithIEDName.subclass:
            return tControlWithIEDName.subclass(*args_, **kwargs_)
        else:
            return tControlWithIEDName(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IEDName(self): return self.IEDName
    def set_IEDName(self, IEDName): self.IEDName = IEDName
    def add_IEDName(self, value): self.IEDName.append(value)
    def insert_IEDName_at(self, index, value): self.IEDName.insert(index, value)
    def replace_IEDName_at(self, index, value): self.IEDName[index] = value
    def get_confRev(self): return self.confRev
    def set_confRev(self, confRev): self.confRev = confRev
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            self.IEDName or
            super(tControlWithIEDName, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tControlWithIEDName', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tControlWithIEDName')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tControlWithIEDName')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tControlWithIEDName', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tControlWithIEDName'):
        super(tControlWithIEDName, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tControlWithIEDName')
        if self.confRev is not None and 'confRev' not in already_processed:
            already_processed.add('confRev')
            outfile.write(' confRev="%s"' % self.gds_format_integer(self.confRev, input_name='confRev'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tControlWithIEDName', fromsubclass_=False, pretty_print=True):
        super(tControlWithIEDName, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IEDName_ in self.IEDName:
            showIndent(outfile, level, pretty_print)
            outfile.write('<scl:IEDName>%s</scl:IEDName>%s' % (self.gds_encode(self.gds_format_string(quote_xml(IEDName_), input_name='IEDName')), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('confRev', node)
        if value is not None and 'confRev' not in already_processed:
            already_processed.add('confRev')
            try:
                self.confRev = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tControlWithIEDName, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IEDName':
            IEDName_ = child_.text
            IEDName_ = self.gds_validate_string(IEDName_, node, 'IEDName')
            self.IEDName.append(IEDName_)
            # validate type tName
            self.validate_tName(self.IEDName[-1])
        super(tControlWithIEDName, self).buildChildren(child_, node, nodeName_, True)
# end class tControlWithIEDName


class tGSEControl(tControlWithIEDName):
    subclass = None
    superclass = tControlWithIEDName
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, confRev=None, IEDName=None, type_='GOOSE', appID=None):
        self.original_tagname_ = None
        super(tGSEControl, self).__init__(anytypeobjs_, Text, Private, name, desc, datSet, confRev, IEDName, )
        self.type_ = _cast(None, type_)
        self.appID = _cast(None, appID)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tGSEControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tGSEControl.subclass:
            return tGSEControl.subclass(*args_, **kwargs_)
        else:
            return tGSEControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_appID(self): return self.appID
    def set_appID(self, appID): self.appID = appID
    def validate_tGSEControlTypeEnum(self, value):
        # Validate type tGSEControlTypeEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GSSE', 'GOOSE']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tGSEControlTypeEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(tGSEControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tGSEControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tGSEControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tGSEControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tGSEControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tGSEControl'):
        super(tGSEControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tGSEControl')
        if self.type_ != "GOOSE" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.appID is not None and 'appID' not in already_processed:
            already_processed.add('appID')
            outfile.write(' appID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.appID), input_name='appID')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tGSEControl', fromsubclass_=False, pretty_print=True):
        super(tGSEControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tGSEControlTypeEnum(self.type_)    # validate type tGSEControlTypeEnum
        value = find_attr_value_('appID', node)
        if value is not None and 'appID' not in already_processed:
            already_processed.add('appID')
            self.appID = value
        super(tGSEControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tGSEControl, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tGSEControl


class tSampledValueControl(tControlWithIEDName):
    subclass = None
    superclass = tControlWithIEDName
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, datSet=None, confRev=None, IEDName=None, smvID=None, multicast=True, smpRate=None, nofASDU=None, SmvOpts=None):
        self.original_tagname_ = None
        super(tSampledValueControl, self).__init__(anytypeobjs_, Text, Private, name, desc, datSet, confRev, IEDName, )
        self.smvID = _cast(None, smvID)
        self.multicast = _cast(bool, multicast)
        self.smpRate = _cast(int, smpRate)
        self.nofASDU = _cast(int, nofASDU)
        self.SmvOpts = SmvOpts
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSampledValueControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSampledValueControl.subclass:
            return tSampledValueControl.subclass(*args_, **kwargs_)
        else:
            return tSampledValueControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SmvOpts(self): return self.SmvOpts
    def set_SmvOpts(self, SmvOpts): self.SmvOpts = SmvOpts
    def get_smvID(self): return self.smvID
    def set_smvID(self, smvID): self.smvID = smvID
    def get_multicast(self): return self.multicast
    def set_multicast(self, multicast): self.multicast = multicast
    def get_smpRate(self): return self.smpRate
    def set_smpRate(self, smpRate): self.smpRate = smpRate
    def get_nofASDU(self): return self.nofASDU
    def set_nofASDU(self, nofASDU): self.nofASDU = nofASDU
    def hasContent_(self):
        if (
            self.SmvOpts is not None or
            super(tSampledValueControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSampledValueControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSampledValueControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSampledValueControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSampledValueControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSampledValueControl'):
        super(tSampledValueControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSampledValueControl')
        if self.smvID is not None and 'smvID' not in already_processed:
            already_processed.add('smvID')
            outfile.write(' smvID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.smvID), input_name='smvID')), ))
        if not self.multicast and 'multicast' not in already_processed:
            already_processed.add('multicast')
            outfile.write(' multicast="%s"' % self.gds_format_boolean(self.multicast, input_name='multicast'))
        if self.smpRate is not None and 'smpRate' not in already_processed:
            already_processed.add('smpRate')
            outfile.write(' smpRate="%s"' % self.gds_format_integer(self.smpRate, input_name='smpRate'))
        if self.nofASDU is not None and 'nofASDU' not in already_processed:
            already_processed.add('nofASDU')
            outfile.write(' nofASDU="%s"' % self.gds_format_integer(self.nofASDU, input_name='nofASDU'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSampledValueControl', fromsubclass_=False, pretty_print=True):
        super(tSampledValueControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SmvOpts is not None:
            self.SmvOpts.export(outfile, level, namespace_, name_='SmvOpts', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('smvID', node)
        if value is not None and 'smvID' not in already_processed:
            already_processed.add('smvID')
            self.smvID = value
        value = find_attr_value_('multicast', node)
        if value is not None and 'multicast' not in already_processed:
            already_processed.add('multicast')
            if value in ('true', '1'):
                self.multicast = True
            elif value in ('false', '0'):
                self.multicast = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('smpRate', node)
        if value is not None and 'smpRate' not in already_processed:
            already_processed.add('smpRate')
            try:
                self.smpRate = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('nofASDU', node)
        if value is not None and 'nofASDU' not in already_processed:
            already_processed.add('nofASDU')
            try:
                self.nofASDU = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tSampledValueControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SmvOpts':
            obj_ = SmvOptsType.factory()
            obj_.build(child_)
            self.SmvOpts = obj_
            obj_.original_tagname_ = 'SmvOpts'
        super(tSampledValueControl, self).buildChildren(child_, node, nodeName_, True)
# end class tSampledValueControl


class tSettingControl(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, numOfSGs=None, actSG=1):
        self.original_tagname_ = None
        super(tSettingControl, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.numOfSGs = _cast(int, numOfSGs)
        self.actSG = _cast(int, actSG)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSettingControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSettingControl.subclass:
            return tSettingControl.subclass(*args_, **kwargs_)
        else:
            return tSettingControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_numOfSGs(self): return self.numOfSGs
    def set_numOfSGs(self, numOfSGs): self.numOfSGs = numOfSGs
    def get_actSG(self): return self.actSG
    def set_actSG(self, actSG): self.actSG = actSG
    def hasContent_(self):
        if (
            super(tSettingControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSettingControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSettingControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSettingControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSettingControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSettingControl'):
        super(tSettingControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSettingControl')
        if self.numOfSGs is not None and 'numOfSGs' not in already_processed:
            already_processed.add('numOfSGs')
            outfile.write(' numOfSGs="%s"' % self.gds_format_integer(self.numOfSGs, input_name='numOfSGs'))
        if self.actSG != 1 and 'actSG' not in already_processed:
            already_processed.add('actSG')
            outfile.write(' actSG="%s"' % self.gds_format_integer(self.actSG, input_name='actSG'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSettingControl', fromsubclass_=False, pretty_print=True):
        super(tSettingControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('numOfSGs', node)
        if value is not None and 'numOfSGs' not in already_processed:
            already_processed.add('numOfSGs')
            try:
                self.numOfSGs = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('actSG', node)
        if value is not None and 'actSG' not in already_processed:
            already_processed.add('actSG')
            try:
                self.actSG = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tSettingControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tSettingControl, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tSettingControl


class tSCLControl(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None):
        self.original_tagname_ = None
        super(tSCLControl, self).__init__(anytypeobjs_, Text, Private, desc, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSCLControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSCLControl.subclass:
            return tSCLControl.subclass(*args_, **kwargs_)
        else:
            return tSCLControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(tSCLControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSCLControl', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSCLControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSCLControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSCLControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSCLControl'):
        super(tSCLControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSCLControl')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSCLControl', fromsubclass_=False, pretty_print=True):
        super(tSCLControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tSCLControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tSCLControl, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tSCLControl


class tDOI(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, ix=None, accessControl=None, SDI=None, DAI=None):
        self.original_tagname_ = None
        super(tDOI, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.name = _cast(None, name)
        self.ix = _cast(int, ix)
        self.accessControl = _cast(None, accessControl)
        if SDI is None:
            self.SDI = []
        else:
            self.SDI = SDI
        if DAI is None:
            self.DAI = []
        else:
            self.DAI = DAI
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDOI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDOI.subclass:
            return tDOI.subclass(*args_, **kwargs_)
        else:
            return tDOI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SDI(self): return self.SDI
    def set_SDI(self, SDI): self.SDI = SDI
    def add_SDI(self, value): self.SDI.append(value)
    def insert_SDI_at(self, index, value): self.SDI.insert(index, value)
    def replace_SDI_at(self, index, value): self.SDI[index] = value
    def get_DAI(self): return self.DAI
    def set_DAI(self, DAI): self.DAI = DAI
    def add_DAI(self, value): self.DAI.append(value)
    def insert_DAI_at(self, index, value): self.DAI.insert(index, value)
    def replace_DAI_at(self, index, value): self.DAI[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_ix(self): return self.ix
    def set_ix(self, ix): self.ix = ix
    def get_accessControl(self): return self.accessControl
    def set_accessControl(self, accessControl): self.accessControl = accessControl
    def validate_tRestrName1stU(self, value):
        # Validate type tRestrName1stU, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tRestrName1stU_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tRestrName1stU_patterns_, ))
    validate_tRestrName1stU_patterns_ = [['^\\p{Lu}[\\d,\\p{L}]*$']]
    def hasContent_(self):
        if (
            self.SDI or
            self.DAI or
            super(tDOI, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDOI', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDOI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDOI')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDOI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDOI'):
        super(tDOI, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDOI')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.ix is not None and 'ix' not in already_processed:
            already_processed.add('ix')
            outfile.write(' ix="%s"' % self.gds_format_integer(self.ix, input_name='ix'))
        if self.accessControl is not None and 'accessControl' not in already_processed:
            already_processed.add('accessControl')
            outfile.write(' accessControl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accessControl), input_name='accessControl')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDOI', fromsubclass_=False, pretty_print=True):
        super(tDOI, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SDI_ in self.SDI:
            SDI_.export(outfile, level, namespace_, name_='SDI', pretty_print=pretty_print)
        for DAI_ in self.DAI:
            DAI_.export(outfile, level, namespace_, name_='DAI', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tRestrName1stU(self.name)    # validate type tRestrName1stU
        value = find_attr_value_('ix', node)
        if value is not None and 'ix' not in already_processed:
            already_processed.add('ix')
            try:
                self.ix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('accessControl', node)
        if value is not None and 'accessControl' not in already_processed:
            already_processed.add('accessControl')
            self.accessControl = value
        super(tDOI, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SDI':
            obj_ = tSDI.factory()
            obj_.build(child_)
            self.SDI.append(obj_)
            obj_.original_tagname_ = 'SDI'
        elif nodeName_ == 'DAI':
            obj_ = tDAI.factory()
            obj_.build(child_)
            self.DAI.append(obj_)
            obj_.original_tagname_ = 'DAI'
        super(tDOI, self).buildChildren(child_, node, nodeName_, True)
# end class tDOI


class tSDI(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, ix=None, SDI=None, DAI=None):
        self.original_tagname_ = None
        super(tSDI, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.name = _cast(None, name)
        self.ix = _cast(int, ix)
        if SDI is None:
            self.SDI = []
        else:
            self.SDI = SDI
        if DAI is None:
            self.DAI = []
        else:
            self.DAI = DAI
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSDI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSDI.subclass:
            return tSDI.subclass(*args_, **kwargs_)
        else:
            return tSDI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SDI(self): return self.SDI
    def set_SDI(self, SDI): self.SDI = SDI
    def add_SDI(self, value): self.SDI.append(value)
    def insert_SDI_at(self, index, value): self.SDI.insert(index, value)
    def replace_SDI_at(self, index, value): self.SDI[index] = value
    def get_DAI(self): return self.DAI
    def set_DAI(self, DAI): self.DAI = DAI
    def add_DAI(self, value): self.DAI.append(value)
    def insert_DAI_at(self, index, value): self.DAI.insert(index, value)
    def replace_DAI_at(self, index, value): self.DAI[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_ix(self): return self.ix
    def set_ix(self, ix): self.ix = ix
    def validate_tAttributeNameEnum(self, value):
        # Validate type tAttributeNameEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.SDI or
            self.DAI or
            super(tSDI, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSDI', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSDI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSDI')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSDI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSDI'):
        super(tSDI, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSDI')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.ix is not None and 'ix' not in already_processed:
            already_processed.add('ix')
            outfile.write(' ix="%s"' % self.gds_format_integer(self.ix, input_name='ix'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSDI', fromsubclass_=False, pretty_print=True):
        super(tSDI, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SDI_ in self.SDI:
            SDI_.export(outfile, level, namespace_, name_='SDI', pretty_print=pretty_print)
        for DAI_ in self.DAI:
            DAI_.export(outfile, level, namespace_, name_='DAI', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tAttributeNameEnum(self.name)    # validate type tAttributeNameEnum
        value = find_attr_value_('ix', node)
        if value is not None and 'ix' not in already_processed:
            already_processed.add('ix')
            try:
                self.ix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tSDI, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SDI':
            obj_ = tSDI.factory()
            obj_.build(child_)
            self.SDI.append(obj_)
            obj_.original_tagname_ = 'SDI'
        elif nodeName_ == 'DAI':
            obj_ = tDAI.factory()
            obj_.build(child_)
            self.DAI.append(obj_)
            obj_.original_tagname_ = 'DAI'
        super(tSDI, self).buildChildren(child_, node, nodeName_, True)
# end class tSDI


class tDAI(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, sAddr=None, valKind='Set', ix=None, Val=None):
        self.original_tagname_ = None
        super(tDAI, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.name = _cast(None, name)
        self.sAddr = _cast(None, sAddr)
        self.valKind = _cast(None, valKind)
        self.ix = _cast(int, ix)
        if Val is None:
            self.Val = []
        else:
            self.Val = Val
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDAI)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDAI.subclass:
            return tDAI.subclass(*args_, **kwargs_)
        else:
            return tDAI(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Val(self): return self.Val
    def set_Val(self, Val): self.Val = Val
    def add_Val(self, value): self.Val.append(value)
    def insert_Val_at(self, index, value): self.Val.insert(index, value)
    def replace_Val_at(self, index, value): self.Val[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sAddr(self): return self.sAddr
    def set_sAddr(self, sAddr): self.sAddr = sAddr
    def get_valKind(self): return self.valKind
    def set_valKind(self, valKind): self.valKind = valKind
    def get_ix(self): return self.ix
    def set_ix(self, ix): self.ix = ix
    def validate_tAttributeNameEnum(self, value):
        # Validate type tAttributeNameEnum, a restriction on None.
        pass
    def validate_tValKindEnum(self, value):
        # Validate type tValKindEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Spec', 'Conf', 'RO', 'Set']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tValKindEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.Val or
            super(tDAI, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDAI', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDAI')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDAI')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDAI', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDAI'):
        super(tDAI, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDAI')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.sAddr is not None and 'sAddr' not in already_processed:
            already_processed.add('sAddr')
            outfile.write(' sAddr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sAddr), input_name='sAddr')), ))
        if self.valKind != "Set" and 'valKind' not in already_processed:
            already_processed.add('valKind')
            outfile.write(' valKind=%s' % (quote_attrib(self.valKind), ))
        if self.ix is not None and 'ix' not in already_processed:
            already_processed.add('ix')
            outfile.write(' ix="%s"' % self.gds_format_integer(self.ix, input_name='ix'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDAI', fromsubclass_=False, pretty_print=True):
        super(tDAI, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Val_ in self.Val:
            Val_.export(outfile, level, namespace_, name_='Val', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tAttributeNameEnum(self.name)    # validate type tAttributeNameEnum
        value = find_attr_value_('sAddr', node)
        if value is not None and 'sAddr' not in already_processed:
            already_processed.add('sAddr')
            self.sAddr = value
        value = find_attr_value_('valKind', node)
        if value is not None and 'valKind' not in already_processed:
            already_processed.add('valKind')
            self.valKind = value
            self.validate_tValKindEnum(self.valKind)    # validate type tValKindEnum
        value = find_attr_value_('ix', node)
        if value is not None and 'ix' not in already_processed:
            already_processed.add('ix')
            try:
                self.ix = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(tDAI, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Val':
            obj_ = tVal.factory()
            obj_.build(child_)
            self.Val.append(obj_)
            obj_.original_tagname_ = 'Val'
        super(tDAI, self).buildChildren(child_, node, nodeName_, True)
# end class tDAI


class tServiceYesNo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceYesNo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceYesNo.subclass:
            return tServiceYesNo.subclass(*args_, **kwargs_)
        else:
            return tServiceYesNo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceYesNo', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceYesNo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceYesNo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceYesNo', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceYesNo'):
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceYesNo', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tServiceYesNo


class tServiceWithMax(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, max=None, extensiontype_=None):
        self.original_tagname_ = None
        self.max = _cast(int, max)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceWithMax)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceWithMax.subclass:
            return tServiceWithMax.subclass(*args_, **kwargs_)
        else:
            return tServiceWithMax(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max(self): return self.max
    def set_max(self, max): self.max = max
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceWithMax', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceWithMax')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMax')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceWithMax', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceWithMax'):
        if self.max is not None and 'max' not in already_processed:
            already_processed.add('max')
            outfile.write(' max="%s"' % self.gds_format_integer(self.max, input_name='max'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceWithMax', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max', node)
        if value is not None and 'max' not in already_processed:
            already_processed.add('max')
            try:
                self.max = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tServiceWithMax


class tServiceWithMaxAndMaxAttributes(tServiceWithMax):
    subclass = None
    superclass = tServiceWithMax
    def __init__(self, max=None, maxAttributes=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tServiceWithMaxAndMaxAttributes, self).__init__(max, extensiontype_, )
        self.maxAttributes = _cast(int, maxAttributes)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceWithMaxAndMaxAttributes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceWithMaxAndMaxAttributes.subclass:
            return tServiceWithMaxAndMaxAttributes.subclass(*args_, **kwargs_)
        else:
            return tServiceWithMaxAndMaxAttributes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxAttributes(self): return self.maxAttributes
    def set_maxAttributes(self, maxAttributes): self.maxAttributes = maxAttributes
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(tServiceWithMaxAndMaxAttributes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributes', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceWithMaxAndMaxAttributes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndMaxAttributes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributes', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributes'):
        super(tServiceWithMaxAndMaxAttributes, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndMaxAttributes')
        if self.maxAttributes is not None and 'maxAttributes' not in already_processed:
            already_processed.add('maxAttributes')
            outfile.write(' maxAttributes="%s"' % self.gds_format_integer(self.maxAttributes, input_name='maxAttributes'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributes', fromsubclass_=False, pretty_print=True):
        super(tServiceWithMaxAndMaxAttributes, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('maxAttributes', node)
        if value is not None and 'maxAttributes' not in already_processed:
            already_processed.add('maxAttributes')
            try:
                self.maxAttributes = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tServiceWithMaxAndMaxAttributes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tServiceWithMaxAndMaxAttributes, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tServiceWithMaxAndMaxAttributes


class tServiceWithMaxAndModify(tServiceWithMax):
    subclass = None
    superclass = tServiceWithMax
    def __init__(self, max=None, modify=True):
        self.original_tagname_ = None
        super(tServiceWithMaxAndModify, self).__init__(max, )
        self.modify = _cast(bool, modify)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceWithMaxAndModify)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceWithMaxAndModify.subclass:
            return tServiceWithMaxAndModify.subclass(*args_, **kwargs_)
        else:
            return tServiceWithMaxAndModify(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modify(self): return self.modify
    def set_modify(self, modify): self.modify = modify
    def hasContent_(self):
        if (
            super(tServiceWithMaxAndModify, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndModify', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceWithMaxAndModify')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndModify')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceWithMaxAndModify', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceWithMaxAndModify'):
        super(tServiceWithMaxAndModify, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndModify')
        if not self.modify and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify="%s"' % self.gds_format_boolean(self.modify, input_name='modify'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndModify', fromsubclass_=False, pretty_print=True):
        super(tServiceWithMaxAndModify, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            if value in ('true', '1'):
                self.modify = True
            elif value in ('false', '0'):
                self.modify = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tServiceWithMaxAndModify, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tServiceWithMaxAndModify, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tServiceWithMaxAndModify


class tServiceWithMaxAndMaxAttributesAndModify(tServiceWithMaxAndMaxAttributes):
    subclass = None
    superclass = tServiceWithMaxAndMaxAttributes
    def __init__(self, max=None, maxAttributes=None, modify=True):
        self.original_tagname_ = None
        super(tServiceWithMaxAndMaxAttributesAndModify, self).__init__(max, maxAttributes, )
        self.modify = _cast(bool, modify)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceWithMaxAndMaxAttributesAndModify)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceWithMaxAndMaxAttributesAndModify.subclass:
            return tServiceWithMaxAndMaxAttributesAndModify.subclass(*args_, **kwargs_)
        else:
            return tServiceWithMaxAndMaxAttributesAndModify(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modify(self): return self.modify
    def set_modify(self, modify): self.modify = modify
    def hasContent_(self):
        if (
            super(tServiceWithMaxAndMaxAttributesAndModify, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributesAndModify', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceWithMaxAndMaxAttributesAndModify')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndMaxAttributesAndModify')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributesAndModify', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributesAndModify'):
        super(tServiceWithMaxAndMaxAttributesAndModify, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndMaxAttributesAndModify')
        if not self.modify and 'modify' not in already_processed:
            already_processed.add('modify')
            outfile.write(' modify="%s"' % self.gds_format_boolean(self.modify, input_name='modify'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndMaxAttributesAndModify', fromsubclass_=False, pretty_print=True):
        super(tServiceWithMaxAndMaxAttributesAndModify, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('modify', node)
        if value is not None and 'modify' not in already_processed:
            already_processed.add('modify')
            if value in ('true', '1'):
                self.modify = True
            elif value in ('false', '0'):
                self.modify = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tServiceWithMaxAndMaxAttributesAndModify, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tServiceWithMaxAndMaxAttributesAndModify, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tServiceWithMaxAndMaxAttributesAndModify


class tServiceWithMaxAndClient(tServiceWithMax):
    subclass = None
    superclass = tServiceWithMax
    def __init__(self, max=None, client=True):
        self.original_tagname_ = None
        super(tServiceWithMaxAndClient, self).__init__(max, )
        self.client = _cast(bool, client)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceWithMaxAndClient)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceWithMaxAndClient.subclass:
            return tServiceWithMaxAndClient.subclass(*args_, **kwargs_)
        else:
            return tServiceWithMaxAndClient(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_client(self): return self.client
    def set_client(self, client): self.client = client
    def hasContent_(self):
        if (
            super(tServiceWithMaxAndClient, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndClient', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceWithMaxAndClient')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndClient')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceWithMaxAndClient', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceWithMaxAndClient'):
        super(tServiceWithMaxAndClient, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceWithMaxAndClient')
        if not self.client and 'client' not in already_processed:
            already_processed.add('client')
            outfile.write(' client="%s"' % self.gds_format_boolean(self.client, input_name='client'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceWithMaxAndClient', fromsubclass_=False, pretty_print=True):
        super(tServiceWithMaxAndClient, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('client', node)
        if value is not None and 'client' not in already_processed:
            already_processed.add('client')
            if value in ('true', '1'):
                self.client = True
            elif value in ('false', '0'):
                self.client = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tServiceWithMaxAndClient, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tServiceWithMaxAndClient, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tServiceWithMaxAndClient


class tServiceSettings(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cbName='Fix', datSet='Fix', extensiontype_=None):
        self.original_tagname_ = None
        self.cbName = _cast(None, cbName)
        self.datSet = _cast(None, datSet)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tServiceSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tServiceSettings.subclass:
            return tServiceSettings.subclass(*args_, **kwargs_)
        else:
            return tServiceSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cbName(self): return self.cbName
    def set_cbName(self, cbName): self.cbName = cbName
    def get_datSet(self): return self.datSet
    def set_datSet(self, datSet): self.datSet = datSet
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tServiceSettingsEnum(self, value):
        # Validate type tServiceSettingsEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dyn', 'Conf', 'Fix']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tServiceSettingsEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tServiceSettings', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tServiceSettings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tServiceSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tServiceSettings', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tServiceSettings'):
        if self.cbName != "Fix" and 'cbName' not in already_processed:
            already_processed.add('cbName')
            outfile.write(' cbName=%s' % (quote_attrib(self.cbName), ))
        if self.datSet != "Fix" and 'datSet' not in already_processed:
            already_processed.add('datSet')
            outfile.write(' datSet=%s' % (quote_attrib(self.datSet), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tServiceSettings', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('cbName', node)
        if value is not None and 'cbName' not in already_processed:
            already_processed.add('cbName')
            self.cbName = value
            self.validate_tServiceSettingsEnum(self.cbName)    # validate type tServiceSettingsEnum
        value = find_attr_value_('datSet', node)
        if value is not None and 'datSet' not in already_processed:
            already_processed.add('datSet')
            self.datSet = value
            self.validate_tServiceSettingsEnum(self.datSet)    # validate type tServiceSettingsEnum
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tServiceSettings


class tReportSettings(tServiceSettings):
    subclass = None
    superclass = tServiceSettings
    def __init__(self, cbName='Fix', datSet='Fix', rptID='Fix', optFields='Fix', bufTime='Fix', trgOps='Fix', intgPd='Fix'):
        self.original_tagname_ = None
        super(tReportSettings, self).__init__(cbName, datSet, )
        self.rptID = _cast(None, rptID)
        self.optFields = _cast(None, optFields)
        self.bufTime = _cast(None, bufTime)
        self.trgOps = _cast(None, trgOps)
        self.intgPd = _cast(None, intgPd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tReportSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tReportSettings.subclass:
            return tReportSettings.subclass(*args_, **kwargs_)
        else:
            return tReportSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rptID(self): return self.rptID
    def set_rptID(self, rptID): self.rptID = rptID
    def get_optFields(self): return self.optFields
    def set_optFields(self, optFields): self.optFields = optFields
    def get_bufTime(self): return self.bufTime
    def set_bufTime(self, bufTime): self.bufTime = bufTime
    def get_trgOps(self): return self.trgOps
    def set_trgOps(self, trgOps): self.trgOps = trgOps
    def get_intgPd(self): return self.intgPd
    def set_intgPd(self, intgPd): self.intgPd = intgPd
    def validate_tServiceSettingsEnum(self, value):
        # Validate type tServiceSettingsEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dyn', 'Conf', 'Fix']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tServiceSettingsEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(tReportSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tReportSettings', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tReportSettings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tReportSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tReportSettings', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tReportSettings'):
        super(tReportSettings, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tReportSettings')
        if self.rptID != "Fix" and 'rptID' not in already_processed:
            already_processed.add('rptID')
            outfile.write(' rptID=%s' % (quote_attrib(self.rptID), ))
        if self.optFields != "Fix" and 'optFields' not in already_processed:
            already_processed.add('optFields')
            outfile.write(' optFields=%s' % (quote_attrib(self.optFields), ))
        if self.bufTime != "Fix" and 'bufTime' not in already_processed:
            already_processed.add('bufTime')
            outfile.write(' bufTime=%s' % (quote_attrib(self.bufTime), ))
        if self.trgOps != "Fix" and 'trgOps' not in already_processed:
            already_processed.add('trgOps')
            outfile.write(' trgOps=%s' % (quote_attrib(self.trgOps), ))
        if self.intgPd != "Fix" and 'intgPd' not in already_processed:
            already_processed.add('intgPd')
            outfile.write(' intgPd=%s' % (quote_attrib(self.intgPd), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tReportSettings', fromsubclass_=False, pretty_print=True):
        super(tReportSettings, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rptID', node)
        if value is not None and 'rptID' not in already_processed:
            already_processed.add('rptID')
            self.rptID = value
            self.validate_tServiceSettingsEnum(self.rptID)    # validate type tServiceSettingsEnum
        value = find_attr_value_('optFields', node)
        if value is not None and 'optFields' not in already_processed:
            already_processed.add('optFields')
            self.optFields = value
            self.validate_tServiceSettingsEnum(self.optFields)    # validate type tServiceSettingsEnum
        value = find_attr_value_('bufTime', node)
        if value is not None and 'bufTime' not in already_processed:
            already_processed.add('bufTime')
            self.bufTime = value
            self.validate_tServiceSettingsEnum(self.bufTime)    # validate type tServiceSettingsEnum
        value = find_attr_value_('trgOps', node)
        if value is not None and 'trgOps' not in already_processed:
            already_processed.add('trgOps')
            self.trgOps = value
            self.validate_tServiceSettingsEnum(self.trgOps)    # validate type tServiceSettingsEnum
        value = find_attr_value_('intgPd', node)
        if value is not None and 'intgPd' not in already_processed:
            already_processed.add('intgPd')
            self.intgPd = value
            self.validate_tServiceSettingsEnum(self.intgPd)    # validate type tServiceSettingsEnum
        super(tReportSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tReportSettings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tReportSettings


class tLogSettings(tServiceSettings):
    subclass = None
    superclass = tServiceSettings
    def __init__(self, cbName='Fix', datSet='Fix', logEna='Fix', trgOps='Fix', intgPd='Fix'):
        self.original_tagname_ = None
        super(tLogSettings, self).__init__(cbName, datSet, )
        self.logEna = _cast(None, logEna)
        self.trgOps = _cast(None, trgOps)
        self.intgPd = _cast(None, intgPd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLogSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLogSettings.subclass:
            return tLogSettings.subclass(*args_, **kwargs_)
        else:
            return tLogSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_logEna(self): return self.logEna
    def set_logEna(self, logEna): self.logEna = logEna
    def get_trgOps(self): return self.trgOps
    def set_trgOps(self, trgOps): self.trgOps = trgOps
    def get_intgPd(self): return self.intgPd
    def set_intgPd(self, intgPd): self.intgPd = intgPd
    def validate_tServiceSettingsEnum(self, value):
        # Validate type tServiceSettingsEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dyn', 'Conf', 'Fix']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tServiceSettingsEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(tLogSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLogSettings', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLogSettings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLogSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLogSettings', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLogSettings'):
        super(tLogSettings, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLogSettings')
        if self.logEna != "Fix" and 'logEna' not in already_processed:
            already_processed.add('logEna')
            outfile.write(' logEna=%s' % (quote_attrib(self.logEna), ))
        if self.trgOps != "Fix" and 'trgOps' not in already_processed:
            already_processed.add('trgOps')
            outfile.write(' trgOps=%s' % (quote_attrib(self.trgOps), ))
        if self.intgPd != "Fix" and 'intgPd' not in already_processed:
            already_processed.add('intgPd')
            outfile.write(' intgPd=%s' % (quote_attrib(self.intgPd), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLogSettings', fromsubclass_=False, pretty_print=True):
        super(tLogSettings, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('logEna', node)
        if value is not None and 'logEna' not in already_processed:
            already_processed.add('logEna')
            self.logEna = value
            self.validate_tServiceSettingsEnum(self.logEna)    # validate type tServiceSettingsEnum
        value = find_attr_value_('trgOps', node)
        if value is not None and 'trgOps' not in already_processed:
            already_processed.add('trgOps')
            self.trgOps = value
            self.validate_tServiceSettingsEnum(self.trgOps)    # validate type tServiceSettingsEnum
        value = find_attr_value_('intgPd', node)
        if value is not None and 'intgPd' not in already_processed:
            already_processed.add('intgPd')
            self.intgPd = value
            self.validate_tServiceSettingsEnum(self.intgPd)    # validate type tServiceSettingsEnum
        super(tLogSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tLogSettings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tLogSettings


class tGSESettings(tServiceSettings):
    subclass = None
    superclass = tServiceSettings
    def __init__(self, cbName='Fix', datSet='Fix', appID='Fix', dataLabel='Fix'):
        self.original_tagname_ = None
        super(tGSESettings, self).__init__(cbName, datSet, )
        self.appID = _cast(None, appID)
        self.dataLabel = _cast(None, dataLabel)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tGSESettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tGSESettings.subclass:
            return tGSESettings.subclass(*args_, **kwargs_)
        else:
            return tGSESettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_appID(self): return self.appID
    def set_appID(self, appID): self.appID = appID
    def get_dataLabel(self): return self.dataLabel
    def set_dataLabel(self, dataLabel): self.dataLabel = dataLabel
    def validate_tServiceSettingsEnum(self, value):
        # Validate type tServiceSettingsEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dyn', 'Conf', 'Fix']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tServiceSettingsEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(tGSESettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tGSESettings', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tGSESettings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tGSESettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tGSESettings', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tGSESettings'):
        super(tGSESettings, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tGSESettings')
        if self.appID != "Fix" and 'appID' not in already_processed:
            already_processed.add('appID')
            outfile.write(' appID=%s' % (quote_attrib(self.appID), ))
        if self.dataLabel != "Fix" and 'dataLabel' not in already_processed:
            already_processed.add('dataLabel')
            outfile.write(' dataLabel=%s' % (quote_attrib(self.dataLabel), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tGSESettings', fromsubclass_=False, pretty_print=True):
        super(tGSESettings, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('appID', node)
        if value is not None and 'appID' not in already_processed:
            already_processed.add('appID')
            self.appID = value
            self.validate_tServiceSettingsEnum(self.appID)    # validate type tServiceSettingsEnum
        value = find_attr_value_('dataLabel', node)
        if value is not None and 'dataLabel' not in already_processed:
            already_processed.add('dataLabel')
            self.dataLabel = value
            self.validate_tServiceSettingsEnum(self.dataLabel)    # validate type tServiceSettingsEnum
        super(tGSESettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tGSESettings, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tGSESettings


class tSMVSettings(tServiceSettings):
    subclass = None
    superclass = tServiceSettings
    def __init__(self, cbName='Fix', datSet='Fix', svID='Fix', optFields='Fix', smpRate='Fix', SmpRate=None):
        self.original_tagname_ = None
        super(tSMVSettings, self).__init__(cbName, datSet, )
        self.svID = _cast(None, svID)
        self.optFields = _cast(None, optFields)
        self.smpRate = _cast(None, smpRate)
        if SmpRate is None:
            self.SmpRate = []
        else:
            self.SmpRate = SmpRate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSMVSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSMVSettings.subclass:
            return tSMVSettings.subclass(*args_, **kwargs_)
        else:
            return tSMVSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SmpRate(self): return self.SmpRate
    def set_SmpRate(self, SmpRate): self.SmpRate = SmpRate
    def add_SmpRate(self, value): self.SmpRate.append(value)
    def insert_SmpRate_at(self, index, value): self.SmpRate.insert(index, value)
    def replace_SmpRate_at(self, index, value): self.SmpRate[index] = value
    def get_svID(self): return self.svID
    def set_svID(self, svID): self.svID = svID
    def get_optFields(self): return self.optFields
    def set_optFields(self, optFields): self.optFields = optFields
    def get_smpRate(self): return self.smpRate
    def set_smpRate(self, smpRate): self.smpRate = smpRate
    def validate_SmpRateType(self, value):
        # Validate type SmpRateType, a restriction on xs:decimal.
        if value is not None and Validate_simpletypes_:
            if value < 0:
                warnings_.warn('Value "%(value)s" does not match xsd minInclusive restriction on SmpRateType' % {"value" : value} )
    def validate_tServiceSettingsEnum(self, value):
        # Validate type tServiceSettingsEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Dyn', 'Conf', 'Fix']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tServiceSettingsEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SmpRate or
            super(tSMVSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSMVSettings', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSMVSettings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSMVSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSMVSettings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSMVSettings'):
        super(tSMVSettings, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSMVSettings')
        if self.svID != "Fix" and 'svID' not in already_processed:
            already_processed.add('svID')
            outfile.write(' svID=%s' % (quote_attrib(self.svID), ))
        if self.optFields != "Fix" and 'optFields' not in already_processed:
            already_processed.add('optFields')
            outfile.write(' optFields=%s' % (quote_attrib(self.optFields), ))
        if self.smpRate != "Fix" and 'smpRate' not in already_processed:
            already_processed.add('smpRate')
            outfile.write(' smpRate=%s' % (quote_attrib(self.smpRate), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSMVSettings', fromsubclass_=False, pretty_print=True):
        super(tSMVSettings, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SmpRate_ in self.SmpRate:
            showIndent(outfile, level, pretty_print)
            outfile.write('<scl:SmpRate>%s</scl:SmpRate>%s' % (self.gds_format_float(SmpRate_, input_name='SmpRate'), eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('svID', node)
        if value is not None and 'svID' not in already_processed:
            already_processed.add('svID')
            self.svID = value
            self.validate_tServiceSettingsEnum(self.svID)    # validate type tServiceSettingsEnum
        value = find_attr_value_('optFields', node)
        if value is not None and 'optFields' not in already_processed:
            already_processed.add('optFields')
            self.optFields = value
            self.validate_tServiceSettingsEnum(self.optFields)    # validate type tServiceSettingsEnum
        value = find_attr_value_('smpRate', node)
        if value is not None and 'smpRate' not in already_processed:
            already_processed.add('smpRate')
            self.smpRate = value
            self.validate_tServiceSettingsEnum(self.smpRate)    # validate type tServiceSettingsEnum
        super(tSMVSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SmpRate':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'SmpRate')
            self.SmpRate.append(fval_)
            # validate type SmpRateType
            self.validate_SmpRateType(self.SmpRate[-1])
        super(tSMVSettings, self).buildChildren(child_, node, nodeName_, True)
# end class tSMVSettings


class tConfLNs(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fixPrefix=False, fixLnInst=False):
        self.original_tagname_ = None
        self.fixPrefix = _cast(bool, fixPrefix)
        self.fixLnInst = _cast(bool, fixLnInst)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tConfLNs)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tConfLNs.subclass:
            return tConfLNs.subclass(*args_, **kwargs_)
        else:
            return tConfLNs(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fixPrefix(self): return self.fixPrefix
    def set_fixPrefix(self, fixPrefix): self.fixPrefix = fixPrefix
    def get_fixLnInst(self): return self.fixLnInst
    def set_fixLnInst(self, fixLnInst): self.fixLnInst = fixLnInst
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tConfLNs', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tConfLNs')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tConfLNs')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tConfLNs', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tConfLNs'):
        if self.fixPrefix and 'fixPrefix' not in already_processed:
            already_processed.add('fixPrefix')
            outfile.write(' fixPrefix="%s"' % self.gds_format_boolean(self.fixPrefix, input_name='fixPrefix'))
        if self.fixLnInst and 'fixLnInst' not in already_processed:
            already_processed.add('fixLnInst')
            outfile.write(' fixLnInst="%s"' % self.gds_format_boolean(self.fixLnInst, input_name='fixLnInst'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tConfLNs', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fixPrefix', node)
        if value is not None and 'fixPrefix' not in already_processed:
            already_processed.add('fixPrefix')
            if value in ('true', '1'):
                self.fixPrefix = True
            elif value in ('false', '0'):
                self.fixPrefix = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('fixLnInst', node)
        if value is not None and 'fixLnInst' not in already_processed:
            already_processed.add('fixLnInst')
            if value in ('true', '1'):
                self.fixLnInst = True
            elif value in ('false', '0'):
                self.fixLnInst = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tConfLNs


class tControlBlock(tUnNaming):
    """A control block within a Logical Device (in LLN0)."""
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, ldInst=None, cbName=None, Address=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tControlBlock, self).__init__(anytypeobjs_, Text, Private, desc, extensiontype_, )
        self.ldInst = _cast(None, ldInst)
        self.cbName = _cast(None, cbName)
        self.Address = Address
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tControlBlock)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tControlBlock.subclass:
            return tControlBlock.subclass(*args_, **kwargs_)
        else:
            return tControlBlock(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_ldInst(self): return self.ldInst
    def set_ldInst(self, ldInst): self.ldInst = ldInst
    def get_cbName(self): return self.cbName
    def set_cbName(self, cbName): self.cbName = cbName
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Address is not None or
            super(tControlBlock, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tControlBlock', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tControlBlock')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tControlBlock')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tControlBlock', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tControlBlock'):
        super(tControlBlock, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tControlBlock')
        if self.ldInst is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            outfile.write(' ldInst=%s' % (quote_attrib(self.ldInst), ))
        if self.cbName is not None and 'cbName' not in already_processed:
            already_processed.add('cbName')
            outfile.write(' cbName=%s' % (quote_attrib(self.cbName), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tControlBlock', fromsubclass_=False, pretty_print=True):
        super(tControlBlock, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ldInst', node)
        if value is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            self.ldInst = value
            self.validate_tName(self.ldInst)    # validate type tName
        value = find_attr_value_('cbName', node)
        if value is not None and 'cbName' not in already_processed:
            already_processed.add('cbName')
            self.cbName = value
            self.validate_tName(self.cbName)    # validate type tName
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tControlBlock, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = tAddress.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        super(tControlBlock, self).buildChildren(child_, node, nodeName_, True)
# end class tControlBlock


class tCommunication(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, SubNetwork=None):
        self.original_tagname_ = None
        super(tCommunication, self).__init__(anytypeobjs_, Text, Private, desc, )
        if SubNetwork is None:
            self.SubNetwork = []
        else:
            self.SubNetwork = SubNetwork
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tCommunication)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tCommunication.subclass:
            return tCommunication.subclass(*args_, **kwargs_)
        else:
            return tCommunication(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubNetwork(self): return self.SubNetwork
    def set_SubNetwork(self, SubNetwork): self.SubNetwork = SubNetwork
    def add_SubNetwork(self, value): self.SubNetwork.append(value)
    def insert_SubNetwork_at(self, index, value): self.SubNetwork.insert(index, value)
    def replace_SubNetwork_at(self, index, value): self.SubNetwork[index] = value
    def hasContent_(self):
        if (
            self.SubNetwork or
            super(tCommunication, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tCommunication', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tCommunication')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tCommunication')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tCommunication', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tCommunication'):
        super(tCommunication, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tCommunication')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tCommunication', fromsubclass_=False, pretty_print=True):
        super(tCommunication, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubNetwork_ in self.SubNetwork:
            SubNetwork_.export(outfile, level, namespace_, name_='SubNetwork', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tCommunication, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubNetwork':
            obj_ = tSubNetwork.factory()
            obj_.build(child_)
            self.SubNetwork.append(obj_)
            obj_.original_tagname_ = 'SubNetwork'
        super(tCommunication, self).buildChildren(child_, node, nodeName_, True)
# end class tCommunication


class tSubNetwork(tNaming):
    """The bus protocol types are defined in IEC 61850 Part 8 and 9"""
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, type_=None, BitRate=None, ConnectedAP=None):
        self.original_tagname_ = None
        super(tSubNetwork, self).__init__(anytypeobjs_, Text, Private, name, desc, )
        self.type_ = _cast(None, type_)
        self.BitRate = BitRate
        if ConnectedAP is None:
            self.ConnectedAP = []
        else:
            self.ConnectedAP = ConnectedAP
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSubNetwork)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSubNetwork.subclass:
            return tSubNetwork.subclass(*args_, **kwargs_)
        else:
            return tSubNetwork(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BitRate(self): return self.BitRate
    def set_BitRate(self, BitRate): self.BitRate = BitRate
    def get_ConnectedAP(self): return self.ConnectedAP
    def set_ConnectedAP(self, ConnectedAP): self.ConnectedAP = ConnectedAP
    def add_ConnectedAP(self, value): self.ConnectedAP.append(value)
    def insert_ConnectedAP_at(self, index, value): self.ConnectedAP.insert(index, value)
    def replace_ConnectedAP_at(self, index, value): self.ConnectedAP[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.BitRate is not None or
            self.ConnectedAP or
            super(tSubNetwork, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSubNetwork', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSubNetwork')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSubNetwork')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSubNetwork', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSubNetwork'):
        super(tSubNetwork, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSubNetwork')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSubNetwork', fromsubclass_=False, pretty_print=True):
        super(tSubNetwork, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BitRate is not None:
            self.BitRate.export(outfile, level, namespace_, name_='BitRate', pretty_print=pretty_print)
        for ConnectedAP_ in self.ConnectedAP:
            ConnectedAP_.export(outfile, level, namespace_, name_='ConnectedAP', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        super(tSubNetwork, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BitRate':
            obj_ = tBitRateInMbPerSec.factory()
            obj_.build(child_)
            self.BitRate = obj_
            obj_.original_tagname_ = 'BitRate'
        elif nodeName_ == 'ConnectedAP':
            obj_ = tConnectedAP.factory()
            obj_.build(child_)
            self.ConnectedAP.append(obj_)
            obj_.original_tagname_ = 'ConnectedAP'
        super(tSubNetwork, self).buildChildren(child_, node, nodeName_, True)
# end class tSubNetwork


class tConnectedAP(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, iedName=None, apName=None, Address=None, GSE=None, SMV=None, PhysConn=None):
        self.original_tagname_ = None
        super(tConnectedAP, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.iedName = _cast(None, iedName)
        self.apName = _cast(None, apName)
        self.Address = Address
        if GSE is None:
            self.GSE = []
        else:
            self.GSE = GSE
        if SMV is None:
            self.SMV = []
        else:
            self.SMV = SMV
        if PhysConn is None:
            self.PhysConn = []
        else:
            self.PhysConn = PhysConn
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tConnectedAP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tConnectedAP.subclass:
            return tConnectedAP.subclass(*args_, **kwargs_)
        else:
            return tConnectedAP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Address(self): return self.Address
    def set_Address(self, Address): self.Address = Address
    def get_GSE(self): return self.GSE
    def set_GSE(self, GSE): self.GSE = GSE
    def add_GSE(self, value): self.GSE.append(value)
    def insert_GSE_at(self, index, value): self.GSE.insert(index, value)
    def replace_GSE_at(self, index, value): self.GSE[index] = value
    def get_SMV(self): return self.SMV
    def set_SMV(self, SMV): self.SMV = SMV
    def add_SMV(self, value): self.SMV.append(value)
    def insert_SMV_at(self, index, value): self.SMV.insert(index, value)
    def replace_SMV_at(self, index, value): self.SMV[index] = value
    def get_PhysConn(self): return self.PhysConn
    def set_PhysConn(self, PhysConn): self.PhysConn = PhysConn
    def add_PhysConn(self, value): self.PhysConn.append(value)
    def insert_PhysConn_at(self, index, value): self.PhysConn.insert(index, value)
    def replace_PhysConn_at(self, index, value): self.PhysConn[index] = value
    def get_iedName(self): return self.iedName
    def set_iedName(self, iedName): self.iedName = iedName
    def get_apName(self): return self.apName
    def set_apName(self, apName): self.apName = apName
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            self.Address is not None or
            self.GSE or
            self.SMV or
            self.PhysConn or
            super(tConnectedAP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tConnectedAP', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tConnectedAP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tConnectedAP')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tConnectedAP', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tConnectedAP'):
        super(tConnectedAP, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tConnectedAP')
        if self.iedName is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            outfile.write(' iedName=%s' % (quote_attrib(self.iedName), ))
        if self.apName is not None and 'apName' not in already_processed:
            already_processed.add('apName')
            outfile.write(' apName=%s' % (quote_attrib(self.apName), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tConnectedAP', fromsubclass_=False, pretty_print=True):
        super(tConnectedAP, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Address is not None:
            self.Address.export(outfile, level, namespace_, name_='Address', pretty_print=pretty_print)
        for GSE_ in self.GSE:
            GSE_.export(outfile, level, namespace_, name_='GSE', pretty_print=pretty_print)
        for SMV_ in self.SMV:
            SMV_.export(outfile, level, namespace_, name_='SMV', pretty_print=pretty_print)
        for PhysConn_ in self.PhysConn:
            PhysConn_.export(outfile, level, namespace_, name_='PhysConn', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iedName', node)
        if value is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            self.iedName = value
            self.validate_tName(self.iedName)    # validate type tName
        value = find_attr_value_('apName', node)
        if value is not None and 'apName' not in already_processed:
            already_processed.add('apName')
            self.apName = value
            self.validate_tName(self.apName)    # validate type tName
        super(tConnectedAP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Address':
            obj_ = tAddress.factory()
            obj_.build(child_)
            self.Address = obj_
            obj_.original_tagname_ = 'Address'
        elif nodeName_ == 'GSE':
            obj_ = tGSE.factory()
            obj_.build(child_)
            self.GSE.append(obj_)
            obj_.original_tagname_ = 'GSE'
        elif nodeName_ == 'SMV':
            obj_ = tSMV.factory()
            obj_.build(child_)
            self.SMV.append(obj_)
            obj_.original_tagname_ = 'SMV'
        elif nodeName_ == 'PhysConn':
            obj_ = tPhysConn.factory()
            obj_.build(child_)
            self.PhysConn.append(obj_)
            obj_.original_tagname_ = 'PhysConn'
        super(tConnectedAP, self).buildChildren(child_, node, nodeName_, True)
# end class tConnectedAP


class tAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, P=None):
        self.original_tagname_ = None
        if P is None:
            self.P = []
        else:
            self.P = P
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAddress.subclass:
            return tAddress.subclass(*args_, **kwargs_)
        else:
            return tAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def add_P(self, value): self.P.append(value)
    def insert_P_at(self, index, value): self.P.insert(index, value)
    def replace_P_at(self, index, value): self.P[index] = value
    def hasContent_(self):
        if (
            self.P
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAddress', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAddress', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAddress'):
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAddress', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for P_ in self.P:
            P_.export(outfile, level, namespace_, name_='P', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'P':
            class_obj_ = self.get_class_obj_(child_, tP)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.P.append(obj_)
            obj_.original_tagname_ = 'P'
# end class tAddress


class tGSE(tControlBlock):
    subclass = None
    superclass = tControlBlock
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, ldInst=None, cbName=None, Address=None, MinTime=None, MaxTime=None):
        self.original_tagname_ = None
        super(tGSE, self).__init__(anytypeobjs_, Text, Private, desc, ldInst, cbName, Address, )
        self.MinTime = MinTime
        self.MaxTime = MaxTime
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tGSE)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tGSE.subclass:
            return tGSE.subclass(*args_, **kwargs_)
        else:
            return tGSE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MinTime(self): return self.MinTime
    def set_MinTime(self, MinTime): self.MinTime = MinTime
    def get_MaxTime(self): return self.MaxTime
    def set_MaxTime(self, MaxTime): self.MaxTime = MaxTime
    def hasContent_(self):
        if (
            self.MinTime is not None or
            self.MaxTime is not None or
            super(tGSE, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tGSE', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tGSE')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tGSE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tGSE', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tGSE'):
        super(tGSE, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tGSE')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tGSE', fromsubclass_=False, pretty_print=True):
        super(tGSE, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MinTime is not None:
            self.MinTime.export(outfile, level, namespace_, name_='MinTime', pretty_print=pretty_print)
        if self.MaxTime is not None:
            self.MaxTime.export(outfile, level, namespace_, name_='MaxTime', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tGSE, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MinTime':
            obj_ = tDurationInMilliSec.factory()
            obj_.build(child_)
            self.MinTime = obj_
            obj_.original_tagname_ = 'MinTime'
        elif nodeName_ == 'MaxTime':
            obj_ = tDurationInMilliSec.factory()
            obj_.build(child_)
            self.MaxTime = obj_
            obj_.original_tagname_ = 'MaxTime'
        super(tGSE, self).buildChildren(child_, node, nodeName_, True)
# end class tGSE


class tSMV(tControlBlock):
    subclass = None
    superclass = tControlBlock
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, ldInst=None, cbName=None, Address=None):
        self.original_tagname_ = None
        super(tSMV, self).__init__(anytypeobjs_, Text, Private, desc, ldInst, cbName, Address, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSMV)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSMV.subclass:
            return tSMV.subclass(*args_, **kwargs_)
        else:
            return tSMV(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(tSMV, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSMV', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSMV')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSMV')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSMV', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSMV'):
        super(tSMV, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSMV')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSMV', fromsubclass_=False, pretty_print=True):
        super(tSMV, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tSMV, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tSMV, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tSMV


class tPhysConn(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, P=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        if P is None:
            self.P = []
        else:
            self.P = P
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tPhysConn)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tPhysConn.subclass:
            return tPhysConn.subclass(*args_, **kwargs_)
        else:
            return tPhysConn(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_P(self): return self.P
    def set_P(self, P): self.P = P
    def add_P(self, value): self.P.append(value)
    def insert_P_at(self, index, value): self.P.insert(index, value)
    def replace_P_at(self, index, value): self.P[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.P
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tPhysConn', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tPhysConn')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tPhysConn')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tPhysConn', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tPhysConn'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tPhysConn', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for P_ in self.P:
            P_.export(outfile, level, namespace_, name_='P', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'P':
            class_obj_ = self.get_class_obj_(child_, tP)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.P.append(obj_)
            obj_.original_tagname_ = 'P'
# end class tPhysConn


class tP(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP.subclass:
            return tP.subclass(*args_, **kwargs_)
        else:
            return tP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP


class tP_IP(tP):
    """A TCP/IP address"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_IP, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_IP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_IP.subclass:
            return tP_IP.subclass(*args_, **kwargs_)
        else:
            return tP_IP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_IP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_IP', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_IP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_IP')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_IP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_IP'):
        super(tP_IP, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_IP')
        if self.type_ != "IP" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_IP', fromsubclass_=False, pretty_print=True):
        super(tP_IP, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_IP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_IP


class tP_IP_SUBNET(tP):
    """A subnet Mask for TCP/IP profiles"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_IP_SUBNET, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_IP_SUBNET)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_IP_SUBNET.subclass:
            return tP_IP_SUBNET.subclass(*args_, **kwargs_)
        else:
            return tP_IP_SUBNET(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_IP_SUBNET, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_IP-SUBNET', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_IP-SUBNET')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_IP-SUBNET')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_IP-SUBNET', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_IP-SUBNET'):
        super(tP_IP_SUBNET, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_IP-SUBNET')
        if self.type_ != "IP-SUBNET" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_IP-SUBNET', fromsubclass_=False, pretty_print=True):
        super(tP_IP_SUBNET, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_IP_SUBNET, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_IP_SUBNET


class tP_IP_GATEWAY(tP):
    """A First Hop IP gateway address for TCP/IP profiles"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_IP_GATEWAY, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_IP_GATEWAY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_IP_GATEWAY.subclass:
            return tP_IP_GATEWAY.subclass(*args_, **kwargs_)
        else:
            return tP_IP_GATEWAY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_IP_GATEWAY, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_IP-GATEWAY', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_IP-GATEWAY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_IP-GATEWAY')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_IP-GATEWAY', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_IP-GATEWAY'):
        super(tP_IP_GATEWAY, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_IP-GATEWAY')
        if self.type_ != "IP-GATEWAY" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_IP-GATEWAY', fromsubclass_=False, pretty_print=True):
        super(tP_IP_GATEWAY, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_IP_GATEWAY, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_IP_GATEWAY


class tP_OSI_NSAP(tP):
    """An OSI Network Address"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_NSAP, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_NSAP)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_NSAP.subclass:
            return tP_OSI_NSAP.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_NSAP(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_NSAP, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-NSAP', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-NSAP')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-NSAP')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-NSAP', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-NSAP'):
        super(tP_OSI_NSAP, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-NSAP')
        if self.type_ != "OSI-NSAP" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-NSAP', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_NSAP, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_NSAP, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_NSAP


class tP_OSI_TSEL(tP):
    """An OSI Transport Selector"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_TSEL, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_TSEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_TSEL.subclass:
            return tP_OSI_TSEL.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_TSEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_TSEL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-TSEL', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-TSEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-TSEL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-TSEL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-TSEL'):
        super(tP_OSI_TSEL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-TSEL')
        if self.type_ != "OSI-TSEL" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-TSEL', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_TSEL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_TSEL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_TSEL


class tP_OSI_SSEL(tP):
    """An OSI Session Selector"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_SSEL, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_SSEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_SSEL.subclass:
            return tP_OSI_SSEL.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_SSEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_SSEL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-SSEL', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-SSEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-SSEL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-SSEL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-SSEL'):
        super(tP_OSI_SSEL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-SSEL')
        if self.type_ != "OSI-SSEL" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-SSEL', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_SSEL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_SSEL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_SSEL


class tP_OSI_PSEL(tP):
    """An OSI Presentation Selector"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_PSEL, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_PSEL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_PSEL.subclass:
            return tP_OSI_PSEL.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_PSEL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_PSEL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-PSEL', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-PSEL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-PSEL')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-PSEL', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-PSEL'):
        super(tP_OSI_PSEL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-PSEL')
        if self.type_ != "OSI-PSEL" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-PSEL', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_PSEL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_PSEL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_PSEL


class tP_OSI_AP_Title(tP):
    """An OSI ACSE AP Title value"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_AP_Title, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_AP_Title)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_AP_Title.subclass:
            return tP_OSI_AP_Title.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_AP_Title(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_AP_Title, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-AP-Title', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-AP-Title')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AP-Title')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-AP-Title', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-AP-Title'):
        super(tP_OSI_AP_Title, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AP-Title')
        if self.type_ != "OSI-AP-Title" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-AP-Title', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_AP_Title, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_AP_Title, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_AP_Title


class tP_OSI_AP_Invoke(tP):
    """An OSI ACSE AP Invoke ID"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_AP_Invoke, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_AP_Invoke)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_AP_Invoke.subclass:
            return tP_OSI_AP_Invoke.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_AP_Invoke(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_AP_Invoke, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-AP-Invoke', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-AP-Invoke')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AP-Invoke')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-AP-Invoke', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-AP-Invoke'):
        super(tP_OSI_AP_Invoke, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AP-Invoke')
        if self.type_ != "OSI-AP-Invoke" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-AP-Invoke', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_AP_Invoke, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_AP_Invoke, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_AP_Invoke


class tP_OSI_AE_Qualifier(tP):
    """An OSI ACSE AE Qualifier"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_AE_Qualifier, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_AE_Qualifier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_AE_Qualifier.subclass:
            return tP_OSI_AE_Qualifier.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_AE_Qualifier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_AE_Qualifier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-AE-Qualifier', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-AE-Qualifier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AE-Qualifier')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-AE-Qualifier', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-AE-Qualifier'):
        super(tP_OSI_AE_Qualifier, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AE-Qualifier')
        if self.type_ != "OSI-AE-Qualifier" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-AE-Qualifier', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_AE_Qualifier, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_AE_Qualifier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_AE_Qualifier


class tP_OSI_AE_Invoke(tP):
    """An OSI ACSE AE Invoke ID"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_OSI_AE_Invoke, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_OSI_AE_Invoke)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_OSI_AE_Invoke.subclass:
            return tP_OSI_AE_Invoke.subclass(*args_, **kwargs_)
        else:
            return tP_OSI_AE_Invoke(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_OSI_AE_Invoke, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_OSI-AE-Invoke', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_OSI-AE-Invoke')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AE-Invoke')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_OSI-AE-Invoke', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_OSI-AE-Invoke'):
        super(tP_OSI_AE_Invoke, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_OSI-AE-Invoke')
        if self.type_ != "OSI-AE-Invoke" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_OSI-AE-Invoke', fromsubclass_=False, pretty_print=True):
        super(tP_OSI_AE_Invoke, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_OSI_AE_Invoke, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_OSI_AE_Invoke


class tP_MAC_Address(tP):
    """A Media Access Address value"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_MAC_Address, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_MAC_Address)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_MAC_Address.subclass:
            return tP_MAC_Address.subclass(*args_, **kwargs_)
        else:
            return tP_MAC_Address(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_MAC_Address, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_MAC-Address', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_MAC-Address')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_MAC-Address')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_MAC-Address', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_MAC-Address'):
        super(tP_MAC_Address, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_MAC-Address')
        if self.type_ != "MAC-Address" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_MAC-Address', fromsubclass_=False, pretty_print=True):
        super(tP_MAC_Address, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_MAC_Address, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_MAC_Address


class tP_APPID(tP):
    """An Application Identifier"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_APPID, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_APPID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_APPID.subclass:
            return tP_APPID.subclass(*args_, **kwargs_)
        else:
            return tP_APPID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_APPID, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_APPID', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_APPID')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_APPID')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_APPID', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_APPID'):
        super(tP_APPID, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_APPID')
        if self.type_ != "APPID" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_APPID', fromsubclass_=False, pretty_print=True):
        super(tP_APPID, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_APPID, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_APPID


class tP_VLAN_PRIORITY(tP):
    """A VLAN User Priority"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_VLAN_PRIORITY, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_VLAN_PRIORITY)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_VLAN_PRIORITY.subclass:
            return tP_VLAN_PRIORITY.subclass(*args_, **kwargs_)
        else:
            return tP_VLAN_PRIORITY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_VLAN_PRIORITY, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_VLAN-PRIORITY', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_VLAN-PRIORITY')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_VLAN-PRIORITY')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_VLAN-PRIORITY', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_VLAN-PRIORITY'):
        super(tP_VLAN_PRIORITY, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_VLAN-PRIORITY')
        if self.type_ != "VLAN-PRIORITY" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_VLAN-PRIORITY', fromsubclass_=False, pretty_print=True):
        super(tP_VLAN_PRIORITY, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_VLAN_PRIORITY, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_VLAN_PRIORITY


class tP_VLAN_ID(tP):
    """A VLAN ID"""
    subclass = None
    superclass = tP
    def __init__(self, type_=None, valueOf_=None):
        self.original_tagname_ = None
        super(tP_VLAN_ID, self).__init__(type_, valueOf_, )
        self.type_ = _cast(None, type_)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tP_VLAN_ID)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tP_VLAN_ID.subclass:
            return tP_VLAN_ID.subclass(*args_, **kwargs_)
        else:
            return tP_VLAN_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_tPTypeEnum(self, value):
        # Validate type tPTypeEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_) or
            super(tP_VLAN_ID, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tP_VLAN-ID', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tP_VLAN-ID')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tP_VLAN-ID')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tP_VLAN-ID', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tP_VLAN-ID'):
        super(tP_VLAN_ID, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tP_VLAN-ID')
        if self.type_ != "VLAN-ID" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tP_VLAN-ID', fromsubclass_=False, pretty_print=True):
        super(tP_VLAN_ID, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPTypeEnum(self.type_)    # validate type tPTypeEnum
        super(tP_VLAN_ID, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tP_VLAN_ID


class tAbstractDataAttribute(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, sAddr=None, bType=None, valKind='Set', type_=None, count=0, Val=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tAbstractDataAttribute, self).__init__(anytypeobjs_, Text, Private, desc, extensiontype_, )
        self.name = _cast(None, name)
        self.sAddr = _cast(None, sAddr)
        self.bType = _cast(None, bType)
        self.valKind = _cast(None, valKind)
        self.type_ = _cast(None, type_)
        self.count = _cast(int, count)
        if Val is None:
            self.Val = []
        else:
            self.Val = Val
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAbstractDataAttribute)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAbstractDataAttribute.subclass:
            return tAbstractDataAttribute.subclass(*args_, **kwargs_)
        else:
            return tAbstractDataAttribute(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Val(self): return self.Val
    def set_Val(self, Val): self.Val = Val
    def add_Val(self, value): self.Val.append(value)
    def insert_Val_at(self, index, value): self.Val.insert(index, value)
    def replace_Val_at(self, index, value): self.Val[index] = value
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_sAddr(self): return self.sAddr
    def set_sAddr(self, sAddr): self.sAddr = sAddr
    def get_bType(self): return self.bType
    def set_bType(self, bType): self.bType = bType
    def get_valKind(self): return self.valKind
    def set_valKind(self, valKind): self.valKind = valKind
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def validate_tAttributeNameEnum(self, value):
        # Validate type tAttributeNameEnum, a restriction on None.
        pass
    def validate_tBasicTypeEnum(self, value):
        # Validate type tBasicTypeEnum, a restriction on None.
        pass
    def validate_tValKindEnum(self, value):
        # Validate type tValKindEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Spec', 'Conf', 'RO', 'Set']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tValKindEnum' % {"value" : value.encode("utf-8")} )
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Val or
            super(tAbstractDataAttribute, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAbstractDataAttribute', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAbstractDataAttribute')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAbstractDataAttribute')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAbstractDataAttribute', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAbstractDataAttribute'):
        super(tAbstractDataAttribute, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tAbstractDataAttribute')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.sAddr is not None and 'sAddr' not in already_processed:
            already_processed.add('sAddr')
            outfile.write(' sAddr=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.sAddr), input_name='sAddr')), ))
        if self.bType is not None and 'bType' not in already_processed:
            already_processed.add('bType')
            outfile.write(' bType=%s' % (quote_attrib(self.bType), ))
        if self.valKind != "Set" and 'valKind' not in already_processed:
            already_processed.add('valKind')
            outfile.write(' valKind=%s' % (quote_attrib(self.valKind), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.count != 0 and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAbstractDataAttribute', fromsubclass_=False, pretty_print=True):
        super(tAbstractDataAttribute, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Val_ in self.Val:
            Val_.export(outfile, level, namespace_, name_='Val', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tAttributeNameEnum(self.name)    # validate type tAttributeNameEnum
        value = find_attr_value_('sAddr', node)
        if value is not None and 'sAddr' not in already_processed:
            already_processed.add('sAddr')
            self.sAddr = value
        value = find_attr_value_('bType', node)
        if value is not None and 'bType' not in already_processed:
            already_processed.add('bType')
            self.bType = value
            self.validate_tBasicTypeEnum(self.bType)    # validate type tBasicTypeEnum
        value = find_attr_value_('valKind', node)
        if value is not None and 'valKind' not in already_processed:
            already_processed.add('valKind')
            self.valKind = value
            self.validate_tValKindEnum(self.valKind)    # validate type tValKindEnum
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tAnyName(self.type_)    # validate type tAnyName
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tAbstractDataAttribute, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Val':
            obj_ = tVal.factory()
            obj_.build(child_)
            self.Val.append(obj_)
            obj_.original_tagname_ = 'Val'
        super(tAbstractDataAttribute, self).buildChildren(child_, node, nodeName_, True)
# end class tAbstractDataAttribute


class tLNodeType(tIDNaming):
    subclass = None
    superclass = tIDNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, id=None, desc=None, iedType='', lnClass=None, DO=None):
        self.original_tagname_ = None
        super(tLNodeType, self).__init__(anytypeobjs_, Text, Private, id, desc, )
        self.iedType = _cast(None, iedType)
        self.lnClass = _cast(None, lnClass)
        if DO is None:
            self.DO = []
        else:
            self.DO = DO
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLNodeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLNodeType.subclass:
            return tLNodeType.subclass(*args_, **kwargs_)
        else:
            return tLNodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DO(self): return self.DO
    def set_DO(self, DO): self.DO = DO
    def add_DO(self, value): self.DO.append(value)
    def insert_DO_at(self, index, value): self.DO.insert(index, value)
    def replace_DO_at(self, index, value): self.DO[index] = value
    def get_iedType(self): return self.iedType
    def set_iedType(self, iedType): self.iedType = iedType
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.DO or
            super(tLNodeType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLNodeType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLNodeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLNodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLNodeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLNodeType'):
        super(tLNodeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLNodeType')
        if self.iedType != "" and 'iedType' not in already_processed:
            already_processed.add('iedType')
            outfile.write(' iedType=%s' % (quote_attrib(self.iedType), ))
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLNodeType', fromsubclass_=False, pretty_print=True):
        super(tLNodeType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DO_ in self.DO:
            DO_.export(outfile, level, namespace_, name_='DO', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iedType', node)
        if value is not None and 'iedType' not in already_processed:
            already_processed.add('iedType')
            self.iedType = value
            self.validate_tAnyName(self.iedType)    # validate type tAnyName
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        super(tLNodeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DO':
            obj_ = tDO.factory()
            obj_.build(child_)
            self.DO.append(obj_)
            obj_.original_tagname_ = 'DO'
        super(tLNodeType, self).buildChildren(child_, node, nodeName_, True)
# end class tLNodeType


class tDO(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, type_=None, accessControl=None, transient=False):
        self.original_tagname_ = None
        super(tDO, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.name = _cast(None, name)
        self.type_ = _cast(None, type_)
        self.accessControl = _cast(None, accessControl)
        self.transient = _cast(bool, transient)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDO.subclass:
            return tDO.subclass(*args_, **kwargs_)
        else:
            return tDO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_accessControl(self): return self.accessControl
    def set_accessControl(self, accessControl): self.accessControl = accessControl
    def get_transient(self): return self.transient
    def set_transient(self, transient): self.transient = transient
    def validate_tRestrName1stU(self, value):
        # Validate type tRestrName1stU, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tRestrName1stU_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tRestrName1stU_patterns_, ))
    validate_tRestrName1stU_patterns_ = [['^\\p{Lu}[\\d,\\p{L}]*$']]
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tDO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDO', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDO'):
        super(tDO, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDO')
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.accessControl is not None and 'accessControl' not in already_processed:
            already_processed.add('accessControl')
            outfile.write(' accessControl=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.accessControl), input_name='accessControl')), ))
        if self.transient and 'transient' not in already_processed:
            already_processed.add('transient')
            outfile.write(' transient="%s"' % self.gds_format_boolean(self.transient, input_name='transient'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDO', fromsubclass_=False, pretty_print=True):
        super(tDO, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tRestrName1stU(self.name)    # validate type tRestrName1stU
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tName(self.type_)    # validate type tName
        value = find_attr_value_('accessControl', node)
        if value is not None and 'accessControl' not in already_processed:
            already_processed.add('accessControl')
            self.accessControl = value
        value = find_attr_value_('transient', node)
        if value is not None and 'transient' not in already_processed:
            already_processed.add('transient')
            if value in ('true', '1'):
                self.transient = True
            elif value in ('false', '0'):
                self.transient = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tDO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tDO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tDO


class tDOType(tIDNaming):
    subclass = None
    superclass = tIDNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, id=None, desc=None, iedType='', cdc=None, SDO=None, DA=None):
        self.original_tagname_ = None
        super(tDOType, self).__init__(anytypeobjs_, Text, Private, id, desc, )
        self.iedType = _cast(None, iedType)
        self.cdc = _cast(None, cdc)
        if SDO is None:
            self.SDO = []
        else:
            self.SDO = SDO
        if DA is None:
            self.DA = []
        else:
            self.DA = DA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDOType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDOType.subclass:
            return tDOType.subclass(*args_, **kwargs_)
        else:
            return tDOType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SDO(self): return self.SDO
    def set_SDO(self, SDO): self.SDO = SDO
    def add_SDO(self, value): self.SDO.append(value)
    def insert_SDO_at(self, index, value): self.SDO.insert(index, value)
    def replace_SDO_at(self, index, value): self.SDO[index] = value
    def get_DA(self): return self.DA
    def set_DA(self, DA): self.DA = DA
    def add_DA(self, value): self.DA.append(value)
    def insert_DA_at(self, index, value): self.DA.insert(index, value)
    def replace_DA_at(self, index, value): self.DA[index] = value
    def get_iedType(self): return self.iedType
    def set_iedType(self, iedType): self.iedType = iedType
    def get_cdc(self): return self.cdc
    def set_cdc(self, cdc): self.cdc = cdc
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tCDCEnum(self, value):
        # Validate type tCDCEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.SDO or
            self.DA or
            super(tDOType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDOType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDOType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDOType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDOType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDOType'):
        super(tDOType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDOType')
        if self.iedType != "" and 'iedType' not in already_processed:
            already_processed.add('iedType')
            outfile.write(' iedType=%s' % (quote_attrib(self.iedType), ))
        if self.cdc is not None and 'cdc' not in already_processed:
            already_processed.add('cdc')
            outfile.write(' cdc=%s' % (quote_attrib(self.cdc), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDOType', fromsubclass_=False, pretty_print=True):
        super(tDOType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SDO_ in self.SDO:
            SDO_.export(outfile, level, namespace_, name_='SDO', pretty_print=pretty_print)
        for DA_ in self.DA:
            DA_.export(outfile, level, namespace_, name_='DA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iedType', node)
        if value is not None and 'iedType' not in already_processed:
            already_processed.add('iedType')
            self.iedType = value
            self.validate_tAnyName(self.iedType)    # validate type tAnyName
        value = find_attr_value_('cdc', node)
        if value is not None and 'cdc' not in already_processed:
            already_processed.add('cdc')
            self.cdc = value
            self.validate_tCDCEnum(self.cdc)    # validate type tCDCEnum
        super(tDOType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SDO':
            obj_ = tSDO.factory()
            obj_.build(child_)
            self.SDO.append(obj_)
            obj_.original_tagname_ = 'SDO'
        elif nodeName_ == 'DA':
            obj_ = tDA.factory()
            obj_.build(child_)
            self.DA.append(obj_)
            obj_.original_tagname_ = 'DA'
        super(tDOType, self).buildChildren(child_, node, nodeName_, True)
# end class tDOType


class tSDO(tNaming):
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, type_=None):
        self.original_tagname_ = None
        super(tSDO, self).__init__(anytypeobjs_, Text, Private, name, desc, )
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSDO)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSDO.subclass:
            return tSDO.subclass(*args_, **kwargs_)
        else:
            return tSDO(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tSDO, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSDO', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSDO')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSDO')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSDO', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSDO'):
        super(tSDO, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSDO')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSDO', fromsubclass_=False, pretty_print=True):
        super(tSDO, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tName(self.type_)    # validate type tName
        super(tSDO, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tSDO, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tSDO


class tDA(tAbstractDataAttribute):
    subclass = None
    superclass = tAbstractDataAttribute
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, sAddr=None, bType=None, valKind='Set', type_=None, count=0, Val=None, fc=None, dchg=False, qchg=False, dupd=False):
        self.original_tagname_ = None
        super(tDA, self).__init__(anytypeobjs_, Text, Private, desc, name, sAddr, bType, valKind, type_, count, Val, )
        self.fc = _cast(None, fc)
        self.dchg = _cast(bool, dchg)
        self.qchg = _cast(bool, qchg)
        self.dupd = _cast(bool, dupd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDA.subclass:
            return tDA.subclass(*args_, **kwargs_)
        else:
            return tDA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fc(self): return self.fc
    def set_fc(self, fc): self.fc = fc
    def get_dchg(self): return self.dchg
    def set_dchg(self, dchg): self.dchg = dchg
    def get_qchg(self): return self.qchg
    def set_qchg(self, qchg): self.qchg = qchg
    def get_dupd(self): return self.dupd
    def set_dupd(self, dupd): self.dupd = dupd
    def validate_tFCEnum(self, value):
        # Validate type tFCEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['ST', 'MX', 'CO', 'SP', 'SG', 'SE', 'SV', 'CF', 'DC', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tFCEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(tDA, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDA', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDA'):
        super(tDA, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDA')
        if self.fc is not None and 'fc' not in already_processed:
            already_processed.add('fc')
            outfile.write(' fc=%s' % (quote_attrib(self.fc), ))
        if self.dchg and 'dchg' not in already_processed:
            already_processed.add('dchg')
            outfile.write(' dchg="%s"' % self.gds_format_boolean(self.dchg, input_name='dchg'))
        if self.qchg and 'qchg' not in already_processed:
            already_processed.add('qchg')
            outfile.write(' qchg="%s"' % self.gds_format_boolean(self.qchg, input_name='qchg'))
        if self.dupd and 'dupd' not in already_processed:
            already_processed.add('dupd')
            outfile.write(' dupd="%s"' % self.gds_format_boolean(self.dupd, input_name='dupd'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDA', fromsubclass_=False, pretty_print=True):
        super(tDA, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('fc', node)
        if value is not None and 'fc' not in already_processed:
            already_processed.add('fc')
            self.fc = value
            self.validate_tFCEnum(self.fc)    # validate type tFCEnum
        value = find_attr_value_('dchg', node)
        if value is not None and 'dchg' not in already_processed:
            already_processed.add('dchg')
            if value in ('true', '1'):
                self.dchg = True
            elif value in ('false', '0'):
                self.dchg = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('qchg', node)
        if value is not None and 'qchg' not in already_processed:
            already_processed.add('qchg')
            if value in ('true', '1'):
                self.qchg = True
            elif value in ('false', '0'):
                self.qchg = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dupd', node)
        if value is not None and 'dupd' not in already_processed:
            already_processed.add('dupd')
            if value in ('true', '1'):
                self.dupd = True
            elif value in ('false', '0'):
                self.dupd = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tDA, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tDA, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tDA


class tDAType(tIDNaming):
    subclass = None
    superclass = tIDNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, id=None, desc=None, iedType='', BDA=None):
        self.original_tagname_ = None
        super(tDAType, self).__init__(anytypeobjs_, Text, Private, id, desc, )
        self.iedType = _cast(None, iedType)
        if BDA is None:
            self.BDA = []
        else:
            self.BDA = BDA
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDAType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDAType.subclass:
            return tDAType.subclass(*args_, **kwargs_)
        else:
            return tDAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BDA(self): return self.BDA
    def set_BDA(self, BDA): self.BDA = BDA
    def add_BDA(self, value): self.BDA.append(value)
    def insert_BDA_at(self, index, value): self.BDA.insert(index, value)
    def replace_BDA_at(self, index, value): self.BDA[index] = value
    def get_iedType(self): return self.iedType
    def set_iedType(self, iedType): self.iedType = iedType
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.BDA or
            super(tDAType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDAType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDAType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDAType'):
        super(tDAType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tDAType')
        if self.iedType != "" and 'iedType' not in already_processed:
            already_processed.add('iedType')
            outfile.write(' iedType=%s' % (quote_attrib(self.iedType), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDAType', fromsubclass_=False, pretty_print=True):
        super(tDAType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BDA_ in self.BDA:
            BDA_.export(outfile, level, namespace_, name_='BDA', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('iedType', node)
        if value is not None and 'iedType' not in already_processed:
            already_processed.add('iedType')
            self.iedType = value
            self.validate_tAnyName(self.iedType)    # validate type tAnyName
        super(tDAType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BDA':
            obj_ = tBDA.factory()
            obj_.build(child_)
            self.BDA.append(obj_)
            obj_.original_tagname_ = 'BDA'
        super(tDAType, self).buildChildren(child_, node, nodeName_, True)
# end class tDAType


class tBDA(tAbstractDataAttribute):
    subclass = None
    superclass = tAbstractDataAttribute
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name=None, sAddr=None, bType=None, valKind='Set', type_=None, count=0, Val=None):
        self.original_tagname_ = None
        super(tBDA, self).__init__(anytypeobjs_, Text, Private, desc, name, sAddr, bType, valKind, type_, count, Val, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tBDA)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tBDA.subclass:
            return tBDA.subclass(*args_, **kwargs_)
        else:
            return tBDA(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(tBDA, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tBDA', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tBDA')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tBDA')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tBDA', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tBDA'):
        super(tBDA, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tBDA')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tBDA', fromsubclass_=False, pretty_print=True):
        super(tBDA, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tBDA, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tBDA, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tBDA


class tEnumType(tIDNaming):
    subclass = None
    superclass = tIDNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, id=None, desc=None, EnumVal=None):
        self.original_tagname_ = None
        super(tEnumType, self).__init__(anytypeobjs_, Text, Private, id, desc, )
        if EnumVal is None:
            self.EnumVal = []
        else:
            self.EnumVal = EnumVal
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tEnumType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tEnumType.subclass:
            return tEnumType.subclass(*args_, **kwargs_)
        else:
            return tEnumType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EnumVal(self): return self.EnumVal
    def set_EnumVal(self, EnumVal): self.EnumVal = EnumVal
    def add_EnumVal(self, value): self.EnumVal.append(value)
    def insert_EnumVal_at(self, index, value): self.EnumVal.insert(index, value)
    def replace_EnumVal_at(self, index, value): self.EnumVal[index] = value
    def hasContent_(self):
        if (
            self.EnumVal or
            super(tEnumType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tEnumType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tEnumType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tEnumType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tEnumType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tEnumType'):
        super(tEnumType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tEnumType')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tEnumType', fromsubclass_=False, pretty_print=True):
        super(tEnumType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EnumVal_ in self.EnumVal:
            EnumVal_.export(outfile, level, namespace_, name_='EnumVal', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tEnumType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EnumVal':
            obj_ = tEnumVal.factory()
            obj_.build(child_)
            self.EnumVal.append(obj_)
            obj_.original_tagname_ = 'EnumVal'
        super(tEnumType, self).buildChildren(child_, node, nodeName_, True)
# end class tEnumType


class tEnumVal(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ord=None, valueOf_=None):
        self.original_tagname_ = None
        self.ord = _cast(int, ord)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tEnumVal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tEnumVal.subclass:
            return tEnumVal.subclass(*args_, **kwargs_)
        else:
            return tEnumVal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ord(self): return self.ord
    def set_ord(self, ord): self.ord = ord
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tEnumVal', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tEnumVal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tEnumVal')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tEnumVal', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tEnumVal'):
        if self.ord is not None and 'ord' not in already_processed:
            already_processed.add('ord')
            outfile.write(' ord="%s"' % self.gds_format_integer(self.ord, input_name='ord'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tEnumVal', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ord', node)
        if value is not None and 'ord' not in already_processed:
            already_processed.add('ord')
            try:
                self.ord = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class tEnumVal


class tDataTypeTemplates(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LNodeType=None, DOType=None, DAType=None, EnumType=None):
        self.original_tagname_ = None
        if LNodeType is None:
            self.LNodeType = []
        else:
            self.LNodeType = LNodeType
        if DOType is None:
            self.DOType = []
        else:
            self.DOType = DOType
        if DAType is None:
            self.DAType = []
        else:
            self.DAType = DAType
        if EnumType is None:
            self.EnumType = []
        else:
            self.EnumType = EnumType
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tDataTypeTemplates)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tDataTypeTemplates.subclass:
            return tDataTypeTemplates.subclass(*args_, **kwargs_)
        else:
            return tDataTypeTemplates(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LNodeType(self): return self.LNodeType
    def set_LNodeType(self, LNodeType): self.LNodeType = LNodeType
    def add_LNodeType(self, value): self.LNodeType.append(value)
    def insert_LNodeType_at(self, index, value): self.LNodeType.insert(index, value)
    def replace_LNodeType_at(self, index, value): self.LNodeType[index] = value
    def get_DOType(self): return self.DOType
    def set_DOType(self, DOType): self.DOType = DOType
    def add_DOType(self, value): self.DOType.append(value)
    def insert_DOType_at(self, index, value): self.DOType.insert(index, value)
    def replace_DOType_at(self, index, value): self.DOType[index] = value
    def get_DAType(self): return self.DAType
    def set_DAType(self, DAType): self.DAType = DAType
    def add_DAType(self, value): self.DAType.append(value)
    def insert_DAType_at(self, index, value): self.DAType.insert(index, value)
    def replace_DAType_at(self, index, value): self.DAType[index] = value
    def get_EnumType(self): return self.EnumType
    def set_EnumType(self, EnumType): self.EnumType = EnumType
    def add_EnumType(self, value): self.EnumType.append(value)
    def insert_EnumType_at(self, index, value): self.EnumType.insert(index, value)
    def replace_EnumType_at(self, index, value): self.EnumType[index] = value
    def hasContent_(self):
        if (
            self.LNodeType or
            self.DOType or
            self.DAType or
            self.EnumType
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tDataTypeTemplates', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tDataTypeTemplates')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tDataTypeTemplates')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tDataTypeTemplates', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tDataTypeTemplates'):
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tDataTypeTemplates', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LNodeType_ in self.LNodeType:
            LNodeType_.export(outfile, level, namespace_, name_='LNodeType', pretty_print=pretty_print)
        for DOType_ in self.DOType:
            DOType_.export(outfile, level, namespace_, name_='DOType', pretty_print=pretty_print)
        for DAType_ in self.DAType:
            DAType_.export(outfile, level, namespace_, name_='DAType', pretty_print=pretty_print)
        for EnumType_ in self.EnumType:
            EnumType_.export(outfile, level, namespace_, name_='EnumType', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LNodeType':
            obj_ = tLNodeType.factory()
            obj_.build(child_)
            self.LNodeType.append(obj_)
            obj_.original_tagname_ = 'LNodeType'
        elif nodeName_ == 'DOType':
            obj_ = tDOType.factory()
            obj_.build(child_)
            self.DOType.append(obj_)
            obj_.original_tagname_ = 'DOType'
        elif nodeName_ == 'DAType':
            obj_ = tDAType.factory()
            obj_.build(child_)
            self.DAType.append(obj_)
            obj_.original_tagname_ = 'DAType'
        elif nodeName_ == 'EnumType':
            obj_ = tEnumType.factory()
            obj_.build(child_)
            self.EnumType.append(obj_)
            obj_.original_tagname_ = 'EnumType'
# end class tDataTypeTemplates


class HistoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Hitem=None):
        self.original_tagname_ = None
        if Hitem is None:
            self.Hitem = []
        else:
            self.Hitem = Hitem
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HistoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HistoryType.subclass:
            return HistoryType.subclass(*args_, **kwargs_)
        else:
            return HistoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Hitem(self): return self.Hitem
    def set_Hitem(self, Hitem): self.Hitem = Hitem
    def add_Hitem(self, value): self.Hitem.append(value)
    def insert_Hitem_at(self, index, value): self.Hitem.insert(index, value)
    def replace_Hitem_at(self, index, value): self.Hitem[index] = value
    def hasContent_(self):
        if (
            self.Hitem
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='HistoryType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HistoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='HistoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='HistoryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='HistoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Hitem_ in self.Hitem:
            Hitem_.export(outfile, level, namespace_, name_='Hitem', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Hitem':
            obj_ = tHitem.factory()
            obj_.build(child_)
            self.Hitem.append(obj_)
            obj_.original_tagname_ = 'Hitem'
# end class HistoryType


class SettingGroupsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SGEdit=None, ConfSG=None):
        self.original_tagname_ = None
        self.SGEdit = SGEdit
        self.ConfSG = ConfSG
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SettingGroupsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SettingGroupsType.subclass:
            return SettingGroupsType.subclass(*args_, **kwargs_)
        else:
            return SettingGroupsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SGEdit(self): return self.SGEdit
    def set_SGEdit(self, SGEdit): self.SGEdit = SGEdit
    def get_ConfSG(self): return self.ConfSG
    def set_ConfSG(self, ConfSG): self.ConfSG = ConfSG
    def hasContent_(self):
        if (
            self.SGEdit is not None or
            self.ConfSG is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='SettingGroupsType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SettingGroupsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SettingGroupsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='SettingGroupsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='SettingGroupsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='scl:', name_='SettingGroupsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SGEdit is not None:
            self.SGEdit.export(outfile, level, namespace_, name_='SGEdit', pretty_print=pretty_print)
        if self.ConfSG is not None:
            self.ConfSG.export(outfile, level, namespace_, name_='ConfSG', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SGEdit':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.SGEdit = obj_
            obj_.original_tagname_ = 'SGEdit'
        elif nodeName_ == 'ConfSG':
            obj_ = tServiceYesNo.factory()
            obj_.build(child_)
            self.ConfSG = obj_
            obj_.original_tagname_ = 'ConfSG'
# end class SettingGroupsType


class AuthenticationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, none=True, password=False, weak=False, strong=False, certificate=False):
        self.original_tagname_ = None
        self.none = _cast(bool, none)
        self.password = _cast(bool, password)
        self.weak = _cast(bool, weak)
        self.strong = _cast(bool, strong)
        self.certificate = _cast(bool, certificate)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AuthenticationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AuthenticationType.subclass:
            return AuthenticationType.subclass(*args_, **kwargs_)
        else:
            return AuthenticationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_none(self): return self.none
    def set_none(self, none): self.none = none
    def get_password(self): return self.password
    def set_password(self, password): self.password = password
    def get_weak(self): return self.weak
    def set_weak(self, weak): self.weak = weak
    def get_strong(self): return self.strong
    def set_strong(self, strong): self.strong = strong
    def get_certificate(self): return self.certificate
    def set_certificate(self, certificate): self.certificate = certificate
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='AuthenticationType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AuthenticationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AuthenticationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='AuthenticationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='AuthenticationType'):
        if not self.none and 'none' not in already_processed:
            already_processed.add('none')
            outfile.write(' none="%s"' % self.gds_format_boolean(self.none, input_name='none'))
        if self.password and 'password' not in already_processed:
            already_processed.add('password')
            outfile.write(' password="%s"' % self.gds_format_boolean(self.password, input_name='password'))
        if self.weak and 'weak' not in already_processed:
            already_processed.add('weak')
            outfile.write(' weak="%s"' % self.gds_format_boolean(self.weak, input_name='weak'))
        if self.strong and 'strong' not in already_processed:
            already_processed.add('strong')
            outfile.write(' strong="%s"' % self.gds_format_boolean(self.strong, input_name='strong'))
        if self.certificate and 'certificate' not in already_processed:
            already_processed.add('certificate')
            outfile.write(' certificate="%s"' % self.gds_format_boolean(self.certificate, input_name='certificate'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='AuthenticationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('none', node)
        if value is not None and 'none' not in already_processed:
            already_processed.add('none')
            if value in ('true', '1'):
                self.none = True
            elif value in ('false', '0'):
                self.none = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('password', node)
        if value is not None and 'password' not in already_processed:
            already_processed.add('password')
            if value in ('true', '1'):
                self.password = True
            elif value in ('false', '0'):
                self.password = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('weak', node)
        if value is not None and 'weak' not in already_processed:
            already_processed.add('weak')
            if value in ('true', '1'):
                self.weak = True
            elif value in ('false', '0'):
                self.weak = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('strong', node)
        if value is not None and 'strong' not in already_processed:
            already_processed.add('strong')
            if value in ('true', '1'):
                self.strong = True
            elif value in ('false', '0'):
                self.strong = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('certificate', node)
        if value is not None and 'certificate' not in already_processed:
            already_processed.add('certificate')
            if value in ('true', '1'):
                self.certificate = True
            elif value in ('false', '0'):
                self.certificate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AuthenticationType


class OptFieldsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, seqNum=False, timeStamp=False, dataSet=False, reasonCode=False, dataRef=False, entryID=False, configRef=False, bufOvfl=False, segmentation=False):
        self.original_tagname_ = None
        self.seqNum = _cast(bool, seqNum)
        self.timeStamp = _cast(bool, timeStamp)
        self.dataSet = _cast(bool, dataSet)
        self.reasonCode = _cast(bool, reasonCode)
        self.dataRef = _cast(bool, dataRef)
        self.entryID = _cast(bool, entryID)
        self.configRef = _cast(bool, configRef)
        self.bufOvfl = _cast(bool, bufOvfl)
        self.segmentation = _cast(bool, segmentation)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OptFieldsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OptFieldsType.subclass:
            return OptFieldsType.subclass(*args_, **kwargs_)
        else:
            return OptFieldsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_seqNum(self): return self.seqNum
    def set_seqNum(self, seqNum): self.seqNum = seqNum
    def get_timeStamp(self): return self.timeStamp
    def set_timeStamp(self, timeStamp): self.timeStamp = timeStamp
    def get_dataSet(self): return self.dataSet
    def set_dataSet(self, dataSet): self.dataSet = dataSet
    def get_reasonCode(self): return self.reasonCode
    def set_reasonCode(self, reasonCode): self.reasonCode = reasonCode
    def get_dataRef(self): return self.dataRef
    def set_dataRef(self, dataRef): self.dataRef = dataRef
    def get_entryID(self): return self.entryID
    def set_entryID(self, entryID): self.entryID = entryID
    def get_configRef(self): return self.configRef
    def set_configRef(self, configRef): self.configRef = configRef
    def get_bufOvfl(self): return self.bufOvfl
    def set_bufOvfl(self, bufOvfl): self.bufOvfl = bufOvfl
    def get_segmentation(self): return self.segmentation
    def set_segmentation(self, segmentation): self.segmentation = segmentation
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='OptFieldsType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OptFieldsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OptFieldsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='OptFieldsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='OptFieldsType'):
        if self.seqNum and 'seqNum' not in already_processed:
            already_processed.add('seqNum')
            outfile.write(' seqNum="%s"' % self.gds_format_boolean(self.seqNum, input_name='seqNum'))
        if self.timeStamp and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            outfile.write(' timeStamp="%s"' % self.gds_format_boolean(self.timeStamp, input_name='timeStamp'))
        if self.dataSet and 'dataSet' not in already_processed:
            already_processed.add('dataSet')
            outfile.write(' dataSet="%s"' % self.gds_format_boolean(self.dataSet, input_name='dataSet'))
        if self.reasonCode and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            outfile.write(' reasonCode="%s"' % self.gds_format_boolean(self.reasonCode, input_name='reasonCode'))
        if self.dataRef and 'dataRef' not in already_processed:
            already_processed.add('dataRef')
            outfile.write(' dataRef="%s"' % self.gds_format_boolean(self.dataRef, input_name='dataRef'))
        if self.entryID and 'entryID' not in already_processed:
            already_processed.add('entryID')
            outfile.write(' entryID="%s"' % self.gds_format_boolean(self.entryID, input_name='entryID'))
        if self.configRef and 'configRef' not in already_processed:
            already_processed.add('configRef')
            outfile.write(' configRef="%s"' % self.gds_format_boolean(self.configRef, input_name='configRef'))
        if self.bufOvfl and 'bufOvfl' not in already_processed:
            already_processed.add('bufOvfl')
            outfile.write(' bufOvfl="%s"' % self.gds_format_boolean(self.bufOvfl, input_name='bufOvfl'))
        if self.segmentation and 'segmentation' not in already_processed:
            already_processed.add('segmentation')
            outfile.write(' segmentation="%s"' % self.gds_format_boolean(self.segmentation, input_name='segmentation'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='OptFieldsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('seqNum', node)
        if value is not None and 'seqNum' not in already_processed:
            already_processed.add('seqNum')
            if value in ('true', '1'):
                self.seqNum = True
            elif value in ('false', '0'):
                self.seqNum = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('timeStamp', node)
        if value is not None and 'timeStamp' not in already_processed:
            already_processed.add('timeStamp')
            if value in ('true', '1'):
                self.timeStamp = True
            elif value in ('false', '0'):
                self.timeStamp = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dataSet', node)
        if value is not None and 'dataSet' not in already_processed:
            already_processed.add('dataSet')
            if value in ('true', '1'):
                self.dataSet = True
            elif value in ('false', '0'):
                self.dataSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('reasonCode', node)
        if value is not None and 'reasonCode' not in already_processed:
            already_processed.add('reasonCode')
            if value in ('true', '1'):
                self.reasonCode = True
            elif value in ('false', '0'):
                self.reasonCode = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dataRef', node)
        if value is not None and 'dataRef' not in already_processed:
            already_processed.add('dataRef')
            if value in ('true', '1'):
                self.dataRef = True
            elif value in ('false', '0'):
                self.dataRef = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('entryID', node)
        if value is not None and 'entryID' not in already_processed:
            already_processed.add('entryID')
            if value in ('true', '1'):
                self.entryID = True
            elif value in ('false', '0'):
                self.entryID = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('configRef', node)
        if value is not None and 'configRef' not in already_processed:
            already_processed.add('configRef')
            if value in ('true', '1'):
                self.configRef = True
            elif value in ('false', '0'):
                self.configRef = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('bufOvfl', node)
        if value is not None and 'bufOvfl' not in already_processed:
            already_processed.add('bufOvfl')
            if value in ('true', '1'):
                self.bufOvfl = True
            elif value in ('false', '0'):
                self.bufOvfl = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('segmentation', node)
        if value is not None and 'segmentation' not in already_processed:
            already_processed.add('segmentation')
            if value in ('true', '1'):
                self.segmentation = True
            elif value in ('false', '0'):
                self.segmentation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OptFieldsType


class SmvOptsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refreshTime=False, sampleSynchronized=False, sampleRate=False, security=False, dataRef=False):
        self.original_tagname_ = None
        self.refreshTime = _cast(bool, refreshTime)
        self.sampleSynchronized = _cast(bool, sampleSynchronized)
        self.sampleRate = _cast(bool, sampleRate)
        self.security = _cast(bool, security)
        self.dataRef = _cast(bool, dataRef)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SmvOptsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SmvOptsType.subclass:
            return SmvOptsType.subclass(*args_, **kwargs_)
        else:
            return SmvOptsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refreshTime(self): return self.refreshTime
    def set_refreshTime(self, refreshTime): self.refreshTime = refreshTime
    def get_sampleSynchronized(self): return self.sampleSynchronized
    def set_sampleSynchronized(self, sampleSynchronized): self.sampleSynchronized = sampleSynchronized
    def get_sampleRate(self): return self.sampleRate
    def set_sampleRate(self, sampleRate): self.sampleRate = sampleRate
    def get_security(self): return self.security
    def set_security(self, security): self.security = security
    def get_dataRef(self): return self.dataRef
    def set_dataRef(self, dataRef): self.dataRef = dataRef
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='SmvOptsType', namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SmvOptsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SmvOptsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='SmvOptsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='SmvOptsType'):
        if self.refreshTime and 'refreshTime' not in already_processed:
            already_processed.add('refreshTime')
            outfile.write(' refreshTime="%s"' % self.gds_format_boolean(self.refreshTime, input_name='refreshTime'))
        if self.sampleSynchronized and 'sampleSynchronized' not in already_processed:
            already_processed.add('sampleSynchronized')
            outfile.write(' sampleSynchronized="%s"' % self.gds_format_boolean(self.sampleSynchronized, input_name='sampleSynchronized'))
        if self.sampleRate and 'sampleRate' not in already_processed:
            already_processed.add('sampleRate')
            outfile.write(' sampleRate="%s"' % self.gds_format_boolean(self.sampleRate, input_name='sampleRate'))
        if self.security and 'security' not in already_processed:
            already_processed.add('security')
            outfile.write(' security="%s"' % self.gds_format_boolean(self.security, input_name='security'))
        if self.dataRef and 'dataRef' not in already_processed:
            already_processed.add('dataRef')
            outfile.write(' dataRef="%s"' % self.gds_format_boolean(self.dataRef, input_name='dataRef'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='SmvOptsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refreshTime', node)
        if value is not None and 'refreshTime' not in already_processed:
            already_processed.add('refreshTime')
            if value in ('true', '1'):
                self.refreshTime = True
            elif value in ('false', '0'):
                self.refreshTime = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('sampleSynchronized', node)
        if value is not None and 'sampleSynchronized' not in already_processed:
            already_processed.add('sampleSynchronized')
            if value in ('true', '1'):
                self.sampleSynchronized = True
            elif value in ('false', '0'):
                self.sampleSynchronized = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('sampleRate', node)
        if value is not None and 'sampleRate' not in already_processed:
            already_processed.add('sampleRate')
            if value in ('true', '1'):
                self.sampleRate = True
            elif value in ('false', '0'):
                self.sampleRate = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('security', node)
        if value is not None and 'security' not in already_processed:
            already_processed.add('security')
            if value in ('true', '1'):
                self.security = True
            elif value in ('false', '0'):
                self.security = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('dataRef', node)
        if value is not None and 'dataRef' not in already_processed:
            already_processed.add('dataRef')
            if value in ('true', '1'):
                self.dataRef = True
            elif value in ('false', '0'):
                self.dataRef = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SmvOptsType


class LN0(tLN0):
    subclass = None
    superclass = tLN0
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, lnType=None, DataSet=None, ReportControl=None, LogControl=None, DOI=None, Inputs=None, lnClass='LLN0', inst='', GSEControl=None, SampledValueControl=None, SettingControl=None, SCLControl=None, Log=None):
        self.original_tagname_ = None
        super(LN0, self).__init__(anytypeobjs_, Text, Private, desc, lnType, DataSet, ReportControl, LogControl, DOI, Inputs, lnClass, inst, GSEControl, SampledValueControl, SettingControl, SCLControl, Log, )
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LN0)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LN0.subclass:
            return LN0.subclass(*args_, **kwargs_)
        else:
            return LN0(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(LN0, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='LN0', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LN0')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LN0')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='LN0', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='LN0'):
        super(LN0, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LN0')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='LN0', fromsubclass_=False, pretty_print=True):
        super(LN0, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LN0, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LN0, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LN0


class tTerminal(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, name='', connectivityNode=None, substationName=None, voltageLevelName=None, bayName=None, cNodeName=None):
        self.original_tagname_ = None
        super(tTerminal, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.name = _cast(None, name)
        self.connectivityNode = _cast(None, connectivityNode)
        self.substationName = _cast(None, substationName)
        self.voltageLevelName = _cast(None, voltageLevelName)
        self.bayName = _cast(None, bayName)
        self.cNodeName = _cast(None, cNodeName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tTerminal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tTerminal.subclass:
            return tTerminal.subclass(*args_, **kwargs_)
        else:
            return tTerminal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_connectivityNode(self): return self.connectivityNode
    def set_connectivityNode(self, connectivityNode): self.connectivityNode = connectivityNode
    def get_substationName(self): return self.substationName
    def set_substationName(self, substationName): self.substationName = substationName
    def get_voltageLevelName(self): return self.voltageLevelName
    def set_voltageLevelName(self, voltageLevelName): self.voltageLevelName = voltageLevelName
    def get_bayName(self): return self.bayName
    def set_bayName(self, bayName): self.bayName = bayName
    def get_cNodeName(self): return self.cNodeName
    def set_cNodeName(self, cNodeName): self.cNodeName = cNodeName
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tRef(self, value):
        # Validate type tRef, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tRef_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tRef_patterns_, ))
    validate_tRef_patterns_ = [['^.+/.+/.+/.+$']]
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tTerminal, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tTerminal', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tTerminal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tTerminal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tTerminal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tTerminal'):
        super(tTerminal, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tTerminal')
        if self.name != "" and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
        if self.connectivityNode is not None and 'connectivityNode' not in already_processed:
            already_processed.add('connectivityNode')
            outfile.write(' connectivityNode=%s' % (quote_attrib(self.connectivityNode), ))
        if self.substationName is not None and 'substationName' not in already_processed:
            already_processed.add('substationName')
            outfile.write(' substationName=%s' % (quote_attrib(self.substationName), ))
        if self.voltageLevelName is not None and 'voltageLevelName' not in already_processed:
            already_processed.add('voltageLevelName')
            outfile.write(' voltageLevelName=%s' % (quote_attrib(self.voltageLevelName), ))
        if self.bayName is not None and 'bayName' not in already_processed:
            already_processed.add('bayName')
            outfile.write(' bayName=%s' % (quote_attrib(self.bayName), ))
        if self.cNodeName is not None and 'cNodeName' not in already_processed:
            already_processed.add('cNodeName')
            outfile.write(' cNodeName=%s' % (quote_attrib(self.cNodeName), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tTerminal', fromsubclass_=False, pretty_print=True):
        super(tTerminal, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
            self.validate_tAnyName(self.name)    # validate type tAnyName
        value = find_attr_value_('connectivityNode', node)
        if value is not None and 'connectivityNode' not in already_processed:
            already_processed.add('connectivityNode')
            self.connectivityNode = value
            self.validate_tRef(self.connectivityNode)    # validate type tRef
        value = find_attr_value_('substationName', node)
        if value is not None and 'substationName' not in already_processed:
            already_processed.add('substationName')
            self.substationName = value
            self.validate_tName(self.substationName)    # validate type tName
        value = find_attr_value_('voltageLevelName', node)
        if value is not None and 'voltageLevelName' not in already_processed:
            already_processed.add('voltageLevelName')
            self.voltageLevelName = value
            self.validate_tName(self.voltageLevelName)    # validate type tName
        value = find_attr_value_('bayName', node)
        if value is not None and 'bayName' not in already_processed:
            already_processed.add('bayName')
            self.bayName = value
            self.validate_tName(self.bayName)    # validate type tName
        value = find_attr_value_('cNodeName', node)
        if value is not None and 'cNodeName' not in already_processed:
            already_processed.add('cNodeName')
            self.cNodeName = value
            self.validate_tName(self.cNodeName)    # validate type tName
        super(tTerminal, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tTerminal, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tTerminal


class tLNode(tUnNaming):
    subclass = None
    superclass = tUnNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, desc=None, lnInst='', lnClass=None, iedName='None', ldInst='', prefix='', lnType=None):
        self.original_tagname_ = None
        super(tLNode, self).__init__(anytypeobjs_, Text, Private, desc, )
        self.lnInst = _cast(None, lnInst)
        self.lnClass = _cast(None, lnClass)
        self.iedName = _cast(None, iedName)
        self.ldInst = _cast(None, ldInst)
        self.prefix = _cast(None, prefix)
        self.lnType = _cast(None, lnType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLNode.subclass:
            return tLNode.subclass(*args_, **kwargs_)
        else:
            return tLNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lnInst(self): return self.lnInst
    def set_lnInst(self, lnInst): self.lnInst = lnInst
    def get_lnClass(self): return self.lnClass
    def set_lnClass(self, lnClass): self.lnClass = lnClass
    def get_iedName(self): return self.iedName
    def set_iedName(self, iedName): self.iedName = iedName
    def get_ldInst(self): return self.ldInst
    def set_ldInst(self, ldInst): self.ldInst = ldInst
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def get_lnType(self): return self.lnType
    def set_lnType(self, lnType): self.lnType = lnType
    def validate_tAnyName(self, value):
        # Validate type tAnyName, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_tLNClassEnum(self, value):
        # Validate type tLNClassEnum, a restriction on None.
        pass
    def validate_tName(self, value):
        # Validate type tName, a restriction on tAnyName.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tName' % {"value" : value} )
    def hasContent_(self):
        if (
            super(tLNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLNode'):
        super(tLNode, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLNode')
        if self.lnInst != "" and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            outfile.write(' lnInst=%s' % (quote_attrib(self.lnInst), ))
        if self.lnClass is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            outfile.write(' lnClass=%s' % (quote_attrib(self.lnClass), ))
        if self.iedName != "None" and 'iedName' not in already_processed:
            already_processed.add('iedName')
            outfile.write(' iedName=%s' % (quote_attrib(self.iedName), ))
        if self.ldInst != "" and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            outfile.write(' ldInst=%s' % (quote_attrib(self.ldInst), ))
        if self.prefix != "" and 'prefix' not in already_processed:
            already_processed.add('prefix')
            outfile.write(' prefix=%s' % (quote_attrib(self.prefix), ))
        if self.lnType is not None and 'lnType' not in already_processed:
            already_processed.add('lnType')
            outfile.write(' lnType=%s' % (quote_attrib(self.lnType), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLNode', fromsubclass_=False, pretty_print=True):
        super(tLNode, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lnInst', node)
        if value is not None and 'lnInst' not in already_processed:
            already_processed.add('lnInst')
            self.lnInst = value
            self.validate_tAnyName(self.lnInst)    # validate type tAnyName
        value = find_attr_value_('lnClass', node)
        if value is not None and 'lnClass' not in already_processed:
            already_processed.add('lnClass')
            self.lnClass = value
            self.validate_tLNClassEnum(self.lnClass)    # validate type tLNClassEnum
        value = find_attr_value_('iedName', node)
        if value is not None and 'iedName' not in already_processed:
            already_processed.add('iedName')
            self.iedName = value
            self.validate_tName(self.iedName)    # validate type tName
        value = find_attr_value_('ldInst', node)
        if value is not None and 'ldInst' not in already_processed:
            already_processed.add('ldInst')
            self.ldInst = value
            self.validate_tAnyName(self.ldInst)    # validate type tAnyName
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.add('prefix')
            self.prefix = value
            self.validate_tAnyName(self.prefix)    # validate type tAnyName
        value = find_attr_value_('lnType', node)
        if value is not None and 'lnType' not in already_processed:
            already_processed.add('lnType')
            self.lnType = value
            self.validate_tName(self.lnType)    # validate type tName
        super(tLNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tLNode, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tLNode


class tLNodeContainer(tNaming):
    subclass = None
    superclass = tNaming
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tLNodeContainer, self).__init__(anytypeobjs_, Text, Private, name, desc, extensiontype_, )
        if LNode is None:
            self.LNode = []
        else:
            self.LNode = LNode
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tLNodeContainer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tLNodeContainer.subclass:
            return tLNodeContainer.subclass(*args_, **kwargs_)
        else:
            return tLNodeContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LNode(self): return self.LNode
    def set_LNode(self, LNode): self.LNode = LNode
    def add_LNode(self, value): self.LNode.append(value)
    def insert_LNode_at(self, index, value): self.LNode.insert(index, value)
    def replace_LNode_at(self, index, value): self.LNode[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.LNode or
            super(tLNodeContainer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tLNodeContainer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tLNodeContainer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tLNodeContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tLNodeContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tLNodeContainer'):
        super(tLNodeContainer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tLNodeContainer')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tLNodeContainer', fromsubclass_=False, pretty_print=True):
        super(tLNodeContainer, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LNode_ in self.LNode:
            LNode_.export(outfile, level, namespace_, name_='LNode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tLNodeContainer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LNode':
            obj_ = tLNode.factory()
            obj_.build(child_)
            self.LNode.append(obj_)
            obj_.original_tagname_ = 'LNode'
        super(tLNodeContainer, self).buildChildren(child_, node, nodeName_, True)
# end class tLNodeContainer


class SCL(tBaseElement):
    subclass = None
    superclass = tBaseElement
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, Header=None, Substation=None, Communication=None, IED=None, DataTypeTemplates=None):
        self.original_tagname_ = None
        super(SCL, self).__init__(anytypeobjs_, Text, Private, )
        self.Header = Header
        if Substation is None:
            self.Substation = []
        else:
            self.Substation = Substation
        self.Communication = Communication
        if IED is None:
            self.IED = []
        else:
            self.IED = IED
        self.DataTypeTemplates = DataTypeTemplates
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SCL)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SCL.subclass:
            return SCL.subclass(*args_, **kwargs_)
        else:
            return SCL(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def get_Substation(self): return self.Substation
    def set_Substation(self, Substation): self.Substation = Substation
    def add_Substation(self, value): self.Substation.append(value)
    def insert_Substation_at(self, index, value): self.Substation.insert(index, value)
    def replace_Substation_at(self, index, value): self.Substation[index] = value
    def get_Communication(self): return self.Communication
    def set_Communication(self, Communication): self.Communication = Communication
    def get_IED(self): return self.IED
    def set_IED(self, IED): self.IED = IED
    def add_IED(self, value): self.IED.append(value)
    def insert_IED_at(self, index, value): self.IED.insert(index, value)
    def replace_IED_at(self, index, value): self.IED[index] = value
    def get_DataTypeTemplates(self): return self.DataTypeTemplates
    def set_DataTypeTemplates(self, DataTypeTemplates): self.DataTypeTemplates = DataTypeTemplates
    def hasContent_(self):
        if (
            self.Header is not None or
            self.Substation or
            self.Communication is not None or
            self.IED or
            self.DataTypeTemplates is not None or
            super(SCL, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='SCL', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SCL')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SCL')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='SCL', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='SCL'):
        super(SCL, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SCL')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='SCL', fromsubclass_=False, pretty_print=True):
        super(SCL, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Header is not None:
            self.Header.export(outfile, level, namespace_, name_='Header', pretty_print=pretty_print)
        for Substation_ in self.Substation:
            Substation_.export(outfile, level, namespace_, name_='Substation', pretty_print=pretty_print)
        if self.Communication is not None:
            self.Communication.export(outfile, level, namespace_, name_='Communication', pretty_print=pretty_print)
        for IED_ in self.IED:
            IED_.export(outfile, level, namespace_, name_='IED', pretty_print=pretty_print)
        if self.DataTypeTemplates is not None:
            self.DataTypeTemplates.export(outfile, level, namespace_, name_='DataTypeTemplates', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SCL, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Header':
            obj_ = tHeader.factory()
            obj_.build(child_)
            self.Header = obj_
            obj_.original_tagname_ = 'Header'
        elif nodeName_ == 'Substation':
            obj_ = tSubstation.factory()
            obj_.build(child_)
            self.Substation.append(obj_)
            obj_.original_tagname_ = 'Substation'
        elif nodeName_ == 'Communication':
            obj_ = tCommunication.factory()
            obj_.build(child_)
            self.Communication = obj_
            obj_.original_tagname_ = 'Communication'
        elif nodeName_ == 'IED':
            obj_ = tIED.factory()
            obj_.build(child_)
            self.IED.append(obj_)
            obj_.original_tagname_ = 'IED'
        elif nodeName_ == 'DataTypeTemplates':
            obj_ = tDataTypeTemplates.factory()
            obj_.build(child_)
            self.DataTypeTemplates = obj_
            obj_.original_tagname_ = 'DataTypeTemplates'
        super(SCL, self).buildChildren(child_, node, nodeName_, True)
# end class SCL


class tConnectivityNode(tLNodeContainer):
    subclass = None
    superclass = tLNodeContainer
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, pathName=None):
        self.original_tagname_ = None
        super(tConnectivityNode, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, )
        self.pathName = _cast(None, pathName)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tConnectivityNode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tConnectivityNode.subclass:
            return tConnectivityNode.subclass(*args_, **kwargs_)
        else:
            return tConnectivityNode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pathName(self): return self.pathName
    def set_pathName(self, pathName): self.pathName = pathName
    def validate_tRef(self, value):
        # Validate type tRef, a restriction on xs:normalizedString.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tRef_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tRef_patterns_, ))
    validate_tRef_patterns_ = [['^.+/.+/.+/.+$']]
    def hasContent_(self):
        if (
            super(tConnectivityNode, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tConnectivityNode', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tConnectivityNode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tConnectivityNode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tConnectivityNode', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tConnectivityNode'):
        super(tConnectivityNode, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tConnectivityNode')
        if self.pathName is not None and 'pathName' not in already_processed:
            already_processed.add('pathName')
            outfile.write(' pathName=%s' % (quote_attrib(self.pathName), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tConnectivityNode', fromsubclass_=False, pretty_print=True):
        super(tConnectivityNode, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pathName', node)
        if value is not None and 'pathName' not in already_processed:
            already_processed.add('pathName')
            self.pathName = value
            self.validate_tRef(self.pathName)    # validate type tRef
        super(tConnectivityNode, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tConnectivityNode, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tConnectivityNode


class tPowerSystemResource(tLNodeContainer):
    subclass = None
    superclass = tLNodeContainer
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tPowerSystemResource, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, extensiontype_, )
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tPowerSystemResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tPowerSystemResource.subclass:
            return tPowerSystemResource.subclass(*args_, **kwargs_)
        else:
            return tPowerSystemResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(tPowerSystemResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tPowerSystemResource', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tPowerSystemResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tPowerSystemResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tPowerSystemResource', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tPowerSystemResource'):
        super(tPowerSystemResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tPowerSystemResource')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tPowerSystemResource', fromsubclass_=False, pretty_print=True):
        super(tPowerSystemResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tPowerSystemResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tPowerSystemResource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tPowerSystemResource


class tSubFunction(tPowerSystemResource):
    subclass = None
    superclass = tPowerSystemResource
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, GeneralEquipment=None):
        self.original_tagname_ = None
        super(tSubFunction, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, )
        if GeneralEquipment is None:
            self.GeneralEquipment = []
        else:
            self.GeneralEquipment = GeneralEquipment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSubFunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSubFunction.subclass:
            return tSubFunction.subclass(*args_, **kwargs_)
        else:
            return tSubFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GeneralEquipment(self): return self.GeneralEquipment
    def set_GeneralEquipment(self, GeneralEquipment): self.GeneralEquipment = GeneralEquipment
    def add_GeneralEquipment(self, value): self.GeneralEquipment.append(value)
    def insert_GeneralEquipment_at(self, index, value): self.GeneralEquipment.insert(index, value)
    def replace_GeneralEquipment_at(self, index, value): self.GeneralEquipment[index] = value
    def hasContent_(self):
        if (
            self.GeneralEquipment or
            super(tSubFunction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSubFunction', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSubFunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSubFunction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSubFunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSubFunction'):
        super(tSubFunction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSubFunction')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSubFunction', fromsubclass_=False, pretty_print=True):
        super(tSubFunction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for GeneralEquipment_ in self.GeneralEquipment:
            GeneralEquipment_.export(outfile, level, namespace_, name_='GeneralEquipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tSubFunction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GeneralEquipment':
            obj_ = tGeneralEquipment.factory()
            obj_.build(child_)
            self.GeneralEquipment.append(obj_)
            obj_.original_tagname_ = 'GeneralEquipment'
        super(tSubFunction, self).buildChildren(child_, node, nodeName_, True)
# end class tSubFunction


class tFunction(tPowerSystemResource):
    subclass = None
    superclass = tPowerSystemResource
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, SubFunction=None, GeneralEquipment=None):
        self.original_tagname_ = None
        super(tFunction, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, )
        if SubFunction is None:
            self.SubFunction = []
        else:
            self.SubFunction = SubFunction
        if GeneralEquipment is None:
            self.GeneralEquipment = []
        else:
            self.GeneralEquipment = GeneralEquipment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tFunction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tFunction.subclass:
            return tFunction.subclass(*args_, **kwargs_)
        else:
            return tFunction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubFunction(self): return self.SubFunction
    def set_SubFunction(self, SubFunction): self.SubFunction = SubFunction
    def add_SubFunction(self, value): self.SubFunction.append(value)
    def insert_SubFunction_at(self, index, value): self.SubFunction.insert(index, value)
    def replace_SubFunction_at(self, index, value): self.SubFunction[index] = value
    def get_GeneralEquipment(self): return self.GeneralEquipment
    def set_GeneralEquipment(self, GeneralEquipment): self.GeneralEquipment = GeneralEquipment
    def add_GeneralEquipment(self, value): self.GeneralEquipment.append(value)
    def insert_GeneralEquipment_at(self, index, value): self.GeneralEquipment.insert(index, value)
    def replace_GeneralEquipment_at(self, index, value): self.GeneralEquipment[index] = value
    def hasContent_(self):
        if (
            self.SubFunction or
            self.GeneralEquipment or
            super(tFunction, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tFunction', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tFunction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tFunction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tFunction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tFunction'):
        super(tFunction, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tFunction')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tFunction', fromsubclass_=False, pretty_print=True):
        super(tFunction, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubFunction_ in self.SubFunction:
            SubFunction_.export(outfile, level, namespace_, name_='SubFunction', pretty_print=pretty_print)
        for GeneralEquipment_ in self.GeneralEquipment:
            GeneralEquipment_.export(outfile, level, namespace_, name_='GeneralEquipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tFunction, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubFunction':
            obj_ = tSubFunction.factory()
            obj_.build(child_)
            self.SubFunction.append(obj_)
            obj_.original_tagname_ = 'SubFunction'
        elif nodeName_ == 'GeneralEquipment':
            obj_ = tGeneralEquipment.factory()
            obj_.build(child_)
            self.GeneralEquipment.append(obj_)
            obj_.original_tagname_ = 'GeneralEquipment'
        super(tFunction, self).buildChildren(child_, node, nodeName_, True)
# end class tFunction


class tTapChanger(tPowerSystemResource):
    subclass = None
    superclass = tPowerSystemResource
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, type_='LTC', virtual=False):
        self.original_tagname_ = None
        super(tTapChanger, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, )
        self.type_ = _cast(None, type_)
        self.virtual = _cast(bool, virtual)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tTapChanger)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tTapChanger.subclass:
            return tTapChanger.subclass(*args_, **kwargs_)
        else:
            return tTapChanger(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_virtual(self): return self.virtual
    def set_virtual(self, virtual): self.virtual = virtual
    def hasContent_(self):
        if (
            super(tTapChanger, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tTapChanger', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tTapChanger')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tTapChanger')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tTapChanger', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tTapChanger'):
        super(tTapChanger, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tTapChanger')
        if self.type_ != "LTC" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.type_), input_name='type')), ))
        if self.virtual and 'virtual' not in already_processed:
            already_processed.add('virtual')
            outfile.write(' virtual="%s"' % self.gds_format_boolean(self.virtual, input_name='virtual'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tTapChanger', fromsubclass_=False, pretty_print=True):
        super(tTapChanger, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
        value = find_attr_value_('virtual', node)
        if value is not None and 'virtual' not in already_processed:
            already_processed.add('virtual')
            if value in ('true', '1'):
                self.virtual = True
            elif value in ('false', '0'):
                self.virtual = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tTapChanger, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tTapChanger, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tTapChanger


class tSubEquipment(tPowerSystemResource):
    subclass = None
    superclass = tPowerSystemResource
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, phase='none', virtual=False):
        self.original_tagname_ = None
        super(tSubEquipment, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, )
        self.phase = _cast(None, phase)
        self.virtual = _cast(bool, virtual)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSubEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSubEquipment.subclass:
            return tSubEquipment.subclass(*args_, **kwargs_)
        else:
            return tSubEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_virtual(self): return self.virtual
    def set_virtual(self, virtual): self.virtual = virtual
    def validate_tPhaseEnum(self, value):
        # Validate type tPhaseEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['A', 'B', 'C', 'N', 'all', 'none']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tPhaseEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            super(tSubEquipment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSubEquipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSubEquipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSubEquipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSubEquipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSubEquipment'):
        super(tSubEquipment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSubEquipment')
        if self.phase != "none" and 'phase' not in already_processed:
            already_processed.add('phase')
            outfile.write(' phase=%s' % (quote_attrib(self.phase), ))
        if self.virtual and 'virtual' not in already_processed:
            already_processed.add('virtual')
            outfile.write(' virtual="%s"' % self.gds_format_boolean(self.virtual, input_name='virtual'))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSubEquipment', fromsubclass_=False, pretty_print=True):
        super(tSubEquipment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('phase', node)
        if value is not None and 'phase' not in already_processed:
            already_processed.add('phase')
            self.phase = value
            self.validate_tPhaseEnum(self.phase)    # validate type tPhaseEnum
        value = find_attr_value_('virtual', node)
        if value is not None and 'virtual' not in already_processed:
            already_processed.add('virtual')
            if value in ('true', '1'):
                self.virtual = True
            elif value in ('false', '0'):
                self.virtual = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(tSubEquipment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tSubEquipment, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tSubEquipment


class tEquipment(tPowerSystemResource):
    subclass = None
    superclass = tPowerSystemResource
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, virtual=False, extensiontype_=None):
        self.original_tagname_ = None
        super(tEquipment, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, extensiontype_, )
        self.virtual = _cast(bool, virtual)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tEquipment.subclass:
            return tEquipment.subclass(*args_, **kwargs_)
        else:
            return tEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_virtual(self): return self.virtual
    def set_virtual(self, virtual): self.virtual = virtual
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            super(tEquipment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tEquipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tEquipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tEquipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tEquipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tEquipment'):
        super(tEquipment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tEquipment')
        if self.virtual and 'virtual' not in already_processed:
            already_processed.add('virtual')
            outfile.write(' virtual="%s"' % self.gds_format_boolean(self.virtual, input_name='virtual'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tEquipment', fromsubclass_=False, pretty_print=True):
        super(tEquipment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('virtual', node)
        if value is not None and 'virtual' not in already_processed:
            already_processed.add('virtual')
            if value in ('true', '1'):
                self.virtual = True
            elif value in ('false', '0'):
                self.virtual = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tEquipment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tEquipment, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tEquipment


class tEquipmentContainer(tPowerSystemResource):
    subclass = None
    superclass = tPowerSystemResource
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, PowerTransformer=None, GeneralEquipment=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tEquipmentContainer, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, extensiontype_, )
        if PowerTransformer is None:
            self.PowerTransformer = []
        else:
            self.PowerTransformer = PowerTransformer
        if GeneralEquipment is None:
            self.GeneralEquipment = []
        else:
            self.GeneralEquipment = GeneralEquipment
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tEquipmentContainer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tEquipmentContainer.subclass:
            return tEquipmentContainer.subclass(*args_, **kwargs_)
        else:
            return tEquipmentContainer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PowerTransformer(self): return self.PowerTransformer
    def set_PowerTransformer(self, PowerTransformer): self.PowerTransformer = PowerTransformer
    def add_PowerTransformer(self, value): self.PowerTransformer.append(value)
    def insert_PowerTransformer_at(self, index, value): self.PowerTransformer.insert(index, value)
    def replace_PowerTransformer_at(self, index, value): self.PowerTransformer[index] = value
    def get_GeneralEquipment(self): return self.GeneralEquipment
    def set_GeneralEquipment(self, GeneralEquipment): self.GeneralEquipment = GeneralEquipment
    def add_GeneralEquipment(self, value): self.GeneralEquipment.append(value)
    def insert_GeneralEquipment_at(self, index, value): self.GeneralEquipment.insert(index, value)
    def replace_GeneralEquipment_at(self, index, value): self.GeneralEquipment[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.PowerTransformer or
            self.GeneralEquipment or
            super(tEquipmentContainer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tEquipmentContainer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tEquipmentContainer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tEquipmentContainer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tEquipmentContainer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tEquipmentContainer'):
        super(tEquipmentContainer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tEquipmentContainer')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tEquipmentContainer', fromsubclass_=False, pretty_print=True):
        super(tEquipmentContainer, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PowerTransformer_ in self.PowerTransformer:
            PowerTransformer_.export(outfile, level, namespace_, name_='PowerTransformer', pretty_print=pretty_print)
        for GeneralEquipment_ in self.GeneralEquipment:
            GeneralEquipment_.export(outfile, level, namespace_, name_='GeneralEquipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tEquipmentContainer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PowerTransformer':
            obj_ = tPowerTransformer.factory()
            obj_.build(child_)
            self.PowerTransformer.append(obj_)
            obj_.original_tagname_ = 'PowerTransformer'
        elif nodeName_ == 'GeneralEquipment':
            obj_ = tGeneralEquipment.factory()
            obj_.build(child_)
            self.GeneralEquipment.append(obj_)
            obj_.original_tagname_ = 'GeneralEquipment'
        super(tEquipmentContainer, self).buildChildren(child_, node, nodeName_, True)
# end class tEquipmentContainer


class tBay(tEquipmentContainer):
    subclass = None
    superclass = tEquipmentContainer
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, PowerTransformer=None, GeneralEquipment=None, ConductingEquipment=None, ConnectivityNode=None):
        self.original_tagname_ = None
        super(tBay, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, PowerTransformer, GeneralEquipment, )
        if ConductingEquipment is None:
            self.ConductingEquipment = []
        else:
            self.ConductingEquipment = ConductingEquipment
        if ConnectivityNode is None:
            self.ConnectivityNode = []
        else:
            self.ConnectivityNode = ConnectivityNode
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tBay)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tBay.subclass:
            return tBay.subclass(*args_, **kwargs_)
        else:
            return tBay(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConductingEquipment(self): return self.ConductingEquipment
    def set_ConductingEquipment(self, ConductingEquipment): self.ConductingEquipment = ConductingEquipment
    def add_ConductingEquipment(self, value): self.ConductingEquipment.append(value)
    def insert_ConductingEquipment_at(self, index, value): self.ConductingEquipment.insert(index, value)
    def replace_ConductingEquipment_at(self, index, value): self.ConductingEquipment[index] = value
    def get_ConnectivityNode(self): return self.ConnectivityNode
    def set_ConnectivityNode(self, ConnectivityNode): self.ConnectivityNode = ConnectivityNode
    def add_ConnectivityNode(self, value): self.ConnectivityNode.append(value)
    def insert_ConnectivityNode_at(self, index, value): self.ConnectivityNode.insert(index, value)
    def replace_ConnectivityNode_at(self, index, value): self.ConnectivityNode[index] = value
    def hasContent_(self):
        if (
            self.ConductingEquipment or
            self.ConnectivityNode or
            super(tBay, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tBay', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tBay')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tBay')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tBay', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tBay'):
        super(tBay, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tBay')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tBay', fromsubclass_=False, pretty_print=True):
        super(tBay, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ConductingEquipment_ in self.ConductingEquipment:
            ConductingEquipment_.export(outfile, level, namespace_, name_='ConductingEquipment', pretty_print=pretty_print)
        for ConnectivityNode_ in self.ConnectivityNode:
            ConnectivityNode_.export(outfile, level, namespace_, name_='ConnectivityNode', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tBay, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConductingEquipment':
            obj_ = tConductingEquipment.factory()
            obj_.build(child_)
            self.ConductingEquipment.append(obj_)
            obj_.original_tagname_ = 'ConductingEquipment'
        elif nodeName_ == 'ConnectivityNode':
            obj_ = tConnectivityNode.factory()
            obj_.build(child_)
            self.ConnectivityNode.append(obj_)
            obj_.original_tagname_ = 'ConnectivityNode'
        super(tBay, self).buildChildren(child_, node, nodeName_, True)
# end class tBay


class tVoltageLevel(tEquipmentContainer):
    subclass = None
    superclass = tEquipmentContainer
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, PowerTransformer=None, GeneralEquipment=None, Voltage=None, Bay=None):
        self.original_tagname_ = None
        super(tVoltageLevel, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, PowerTransformer, GeneralEquipment, )
        self.Voltage = Voltage
        if Bay is None:
            self.Bay = []
        else:
            self.Bay = Bay
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tVoltageLevel)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tVoltageLevel.subclass:
            return tVoltageLevel.subclass(*args_, **kwargs_)
        else:
            return tVoltageLevel(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Voltage(self): return self.Voltage
    def set_Voltage(self, Voltage): self.Voltage = Voltage
    def get_Bay(self): return self.Bay
    def set_Bay(self, Bay): self.Bay = Bay
    def add_Bay(self, value): self.Bay.append(value)
    def insert_Bay_at(self, index, value): self.Bay.insert(index, value)
    def replace_Bay_at(self, index, value): self.Bay[index] = value
    def hasContent_(self):
        if (
            self.Voltage is not None or
            self.Bay or
            super(tVoltageLevel, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tVoltageLevel', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tVoltageLevel')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tVoltageLevel')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tVoltageLevel', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tVoltageLevel'):
        super(tVoltageLevel, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tVoltageLevel')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tVoltageLevel', fromsubclass_=False, pretty_print=True):
        super(tVoltageLevel, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Voltage is not None:
            self.Voltage.export(outfile, level, namespace_, name_='Voltage', pretty_print=pretty_print)
        for Bay_ in self.Bay:
            Bay_.export(outfile, level, namespace_, name_='Bay', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tVoltageLevel, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Voltage':
            obj_ = tVoltage.factory()
            obj_.build(child_)
            self.Voltage = obj_
            obj_.original_tagname_ = 'Voltage'
        elif nodeName_ == 'Bay':
            obj_ = tBay.factory()
            obj_.build(child_)
            self.Bay.append(obj_)
            obj_.original_tagname_ = 'Bay'
        super(tVoltageLevel, self).buildChildren(child_, node, nodeName_, True)
# end class tVoltageLevel


class tSubstation(tEquipmentContainer):
    subclass = None
    superclass = tEquipmentContainer
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, PowerTransformer=None, GeneralEquipment=None, VoltageLevel=None, Function=None):
        self.original_tagname_ = None
        super(tSubstation, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, PowerTransformer, GeneralEquipment, )
        if VoltageLevel is None:
            self.VoltageLevel = []
        else:
            self.VoltageLevel = VoltageLevel
        if Function is None:
            self.Function = []
        else:
            self.Function = Function
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tSubstation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tSubstation.subclass:
            return tSubstation.subclass(*args_, **kwargs_)
        else:
            return tSubstation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VoltageLevel(self): return self.VoltageLevel
    def set_VoltageLevel(self, VoltageLevel): self.VoltageLevel = VoltageLevel
    def add_VoltageLevel(self, value): self.VoltageLevel.append(value)
    def insert_VoltageLevel_at(self, index, value): self.VoltageLevel.insert(index, value)
    def replace_VoltageLevel_at(self, index, value): self.VoltageLevel[index] = value
    def get_Function(self): return self.Function
    def set_Function(self, Function): self.Function = Function
    def add_Function(self, value): self.Function.append(value)
    def insert_Function_at(self, index, value): self.Function.insert(index, value)
    def replace_Function_at(self, index, value): self.Function[index] = value
    def hasContent_(self):
        if (
            self.VoltageLevel or
            self.Function or
            super(tSubstation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tSubstation', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tSubstation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tSubstation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tSubstation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tSubstation'):
        super(tSubstation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tSubstation')
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tSubstation', fromsubclass_=False, pretty_print=True):
        super(tSubstation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for VoltageLevel_ in self.VoltageLevel:
            VoltageLevel_.export(outfile, level, namespace_, name_='VoltageLevel', pretty_print=pretty_print)
        for Function_ in self.Function:
            Function_.export(outfile, level, namespace_, name_='Function', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(tSubstation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VoltageLevel':
            obj_ = tVoltageLevel.factory()
            obj_.build(child_)
            self.VoltageLevel.append(obj_)
            obj_.original_tagname_ = 'VoltageLevel'
        elif nodeName_ == 'Function':
            obj_ = tFunction.factory()
            obj_.build(child_)
            self.Function.append(obj_)
            obj_.original_tagname_ = 'Function'
        super(tSubstation, self).buildChildren(child_, node, nodeName_, True)
# end class tSubstation


class tGeneralEquipment(tEquipment):
    subclass = None
    superclass = tEquipment
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, virtual=False, type_=None):
        self.original_tagname_ = None
        super(tGeneralEquipment, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, virtual, )
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tGeneralEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tGeneralEquipment.subclass:
            return tGeneralEquipment.subclass(*args_, **kwargs_)
        else:
            return tGeneralEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_tGeneralEquipmentEnum(self, value):
        # Validate type tGeneralEquipmentEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(tGeneralEquipment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tGeneralEquipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tGeneralEquipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tGeneralEquipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tGeneralEquipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tGeneralEquipment'):
        super(tGeneralEquipment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tGeneralEquipment')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tGeneralEquipment', fromsubclass_=False, pretty_print=True):
        super(tGeneralEquipment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tGeneralEquipmentEnum(self.type_)    # validate type tGeneralEquipmentEnum
        super(tGeneralEquipment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tGeneralEquipment, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tGeneralEquipment


class tPowerTransformer(tEquipment):
    subclass = None
    superclass = tEquipment
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, virtual=False, type_='PTR', TransformerWinding=None):
        self.original_tagname_ = None
        super(tPowerTransformer, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, virtual, )
        self.type_ = _cast(None, type_)
        if TransformerWinding is None:
            self.TransformerWinding = []
        else:
            self.TransformerWinding = TransformerWinding
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tPowerTransformer)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tPowerTransformer.subclass:
            return tPowerTransformer.subclass(*args_, **kwargs_)
        else:
            return tPowerTransformer(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TransformerWinding(self): return self.TransformerWinding
    def set_TransformerWinding(self, TransformerWinding): self.TransformerWinding = TransformerWinding
    def add_TransformerWinding(self, value): self.TransformerWinding.append(value)
    def insert_TransformerWinding_at(self, index, value): self.TransformerWinding.insert(index, value)
    def replace_TransformerWinding_at(self, index, value): self.TransformerWinding[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_tPowerTransformerEnum(self, value):
        # Validate type tPowerTransformerEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PTR']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tPowerTransformerEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TransformerWinding or
            super(tPowerTransformer, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tPowerTransformer', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tPowerTransformer')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tPowerTransformer')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tPowerTransformer', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tPowerTransformer'):
        super(tPowerTransformer, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tPowerTransformer')
        if self.type_ != "PTR" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tPowerTransformer', fromsubclass_=False, pretty_print=True):
        super(tPowerTransformer, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TransformerWinding_ in self.TransformerWinding:
            TransformerWinding_.export(outfile, level, namespace_, name_='TransformerWinding', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tPowerTransformerEnum(self.type_)    # validate type tPowerTransformerEnum
        super(tPowerTransformer, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TransformerWinding':
            obj_ = tTransformerWinding.factory()
            obj_.build(child_)
            self.TransformerWinding.append(obj_)
            obj_.original_tagname_ = 'TransformerWinding'
        super(tPowerTransformer, self).buildChildren(child_, node, nodeName_, True)
# end class tPowerTransformer


class tAbstractConductingEquipment(tEquipment):
    subclass = None
    superclass = tEquipment
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, virtual=False, Terminal=None, SubEquipment=None, extensiontype_=None):
        self.original_tagname_ = None
        super(tAbstractConductingEquipment, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, virtual, extensiontype_, )
        if Terminal is None:
            self.Terminal = []
        else:
            self.Terminal = Terminal
        if SubEquipment is None:
            self.SubEquipment = []
        else:
            self.SubEquipment = SubEquipment
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tAbstractConductingEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tAbstractConductingEquipment.subclass:
            return tAbstractConductingEquipment.subclass(*args_, **kwargs_)
        else:
            return tAbstractConductingEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Terminal(self): return self.Terminal
    def set_Terminal(self, Terminal): self.Terminal = Terminal
    def add_Terminal(self, value): self.Terminal.append(value)
    def insert_Terminal_at(self, index, value): self.Terminal.insert(index, value)
    def replace_Terminal_at(self, index, value): self.Terminal[index] = value
    def get_SubEquipment(self): return self.SubEquipment
    def set_SubEquipment(self, SubEquipment): self.SubEquipment = SubEquipment
    def add_SubEquipment(self, value): self.SubEquipment.append(value)
    def insert_SubEquipment_at(self, index, value): self.SubEquipment.insert(index, value)
    def replace_SubEquipment_at(self, index, value): self.SubEquipment[index] = value
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Terminal or
            self.SubEquipment or
            super(tAbstractConductingEquipment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tAbstractConductingEquipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tAbstractConductingEquipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tAbstractConductingEquipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tAbstractConductingEquipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tAbstractConductingEquipment'):
        super(tAbstractConductingEquipment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tAbstractConductingEquipment')
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tAbstractConductingEquipment', fromsubclass_=False, pretty_print=True):
        super(tAbstractConductingEquipment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Terminal_ in self.Terminal:
            Terminal_.export(outfile, level, namespace_, name_='Terminal', pretty_print=pretty_print)
        for SubEquipment_ in self.SubEquipment:
            SubEquipment_.export(outfile, level, namespace_, name_='SubEquipment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
        super(tAbstractConductingEquipment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Terminal':
            obj_ = tTerminal.factory()
            obj_.build(child_)
            self.Terminal.append(obj_)
            obj_.original_tagname_ = 'Terminal'
        elif nodeName_ == 'SubEquipment':
            obj_ = tSubEquipment.factory()
            obj_.build(child_)
            self.SubEquipment.append(obj_)
            obj_.original_tagname_ = 'SubEquipment'
        super(tAbstractConductingEquipment, self).buildChildren(child_, node, nodeName_, True)
# end class tAbstractConductingEquipment


class tTransformerWinding(tAbstractConductingEquipment):
    subclass = None
    superclass = tAbstractConductingEquipment
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, virtual=False, Terminal=None, SubEquipment=None, type_='PTW', TapChanger=None):
        self.original_tagname_ = None
        super(tTransformerWinding, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, virtual, Terminal, SubEquipment, )
        self.type_ = _cast(None, type_)
        self.TapChanger = TapChanger
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tTransformerWinding)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tTransformerWinding.subclass:
            return tTransformerWinding.subclass(*args_, **kwargs_)
        else:
            return tTransformerWinding(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TapChanger(self): return self.TapChanger
    def set_TapChanger(self, TapChanger): self.TapChanger = TapChanger
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_tTransformerWindingEnum(self, value):
        # Validate type tTransformerWindingEnum, a restriction on xs:Name.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PTW']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tTransformerWindingEnum' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.TapChanger is not None or
            super(tTransformerWinding, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tTransformerWinding', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tTransformerWinding')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tTransformerWinding')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tTransformerWinding', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tTransformerWinding'):
        super(tTransformerWinding, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tTransformerWinding')
        if self.type_ != "PTW" and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tTransformerWinding', fromsubclass_=False, pretty_print=True):
        super(tTransformerWinding, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TapChanger is not None:
            self.TapChanger.export(outfile, level, namespace_, name_='TapChanger', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tTransformerWindingEnum(self.type_)    # validate type tTransformerWindingEnum
        super(tTransformerWinding, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TapChanger':
            obj_ = tTapChanger.factory()
            obj_.build(child_)
            self.TapChanger = obj_
            obj_.original_tagname_ = 'TapChanger'
        super(tTransformerWinding, self).buildChildren(child_, node, nodeName_, True)
# end class tTransformerWinding


class tConductingEquipment(tAbstractConductingEquipment):
    subclass = None
    superclass = tAbstractConductingEquipment
    def __init__(self, anytypeobjs_=None, Text=None, Private=None, name=None, desc=None, LNode=None, virtual=False, Terminal=None, SubEquipment=None, type_=None):
        self.original_tagname_ = None
        super(tConductingEquipment, self).__init__(anytypeobjs_, Text, Private, name, desc, LNode, virtual, Terminal, SubEquipment, )
        self.type_ = _cast(None, type_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, tConductingEquipment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if tConductingEquipment.subclass:
            return tConductingEquipment.subclass(*args_, **kwargs_)
        else:
            return tConductingEquipment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_tCommonConductingEquipmentEnum(self, value):
        # Validate type tCommonConductingEquipmentEnum, a restriction on None.
        pass
    def hasContent_(self):
        if (
            super(tConductingEquipment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='scl:', name_='tConductingEquipment', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('tConductingEquipment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='tConductingEquipment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='scl:', name_='tConductingEquipment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='scl:', name_='tConductingEquipment'):
        super(tConductingEquipment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='tConductingEquipment')
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
    def exportChildren(self, outfile, level, namespace_='scl:', name_='tConductingEquipment', fromsubclass_=False, pretty_print=True):
        super(tConductingEquipment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
            self.validate_tCommonConductingEquipmentEnum(self.type_)    # validate type tCommonConductingEquipmentEnum
        super(tConductingEquipment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(tConductingEquipment, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class tConductingEquipment


GDSClassesMapping = {
    'Communication': tCommunication,
    'DataTypeTemplates': tDataTypeTemplates,
    'IED': tIED,
    'LN': tLN,
    'Substation': tSubstation,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SCL'
        rootClass = SCL
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SCL'
        rootClass = SCL
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SCL'
        rootClass = SCL
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:scl="http://www.iec.ch/61850/2003/SCL"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'SCL'
        rootClass = SCL
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from scl_api import *\n\n')
        sys.stdout.write('import scl_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AuthenticationType",
    "HistoryType",
    "LN0",
    "OptFieldsType",
    "SCL",
    "SettingGroupsType",
    "SmvOptsType",
    "tAbstractConductingEquipment",
    "tAbstractDataAttribute",
    "tAccessControl",
    "tAccessPoint",
    "tAddress",
    "tAnyContentFromOtherNamespace",
    "tAnyLN",
    "tAssociation",
    "tBDA",
    "tBaseElement",
    "tBay",
    "tBitRateInMbPerSec",
    "tClientLN",
    "tCommunication",
    "tConductingEquipment",
    "tConfLNs",
    "tConnectedAP",
    "tConnectivityNode",
    "tControl",
    "tControlBlock",
    "tControlWithIEDName",
    "tControlWithTriggerOpt",
    "tDA",
    "tDAI",
    "tDAType",
    "tDO",
    "tDOI",
    "tDOType",
    "tDataSet",
    "tDataTypeTemplates",
    "tDurationInMilliSec",
    "tDurationInSec",
    "tEnumType",
    "tEnumVal",
    "tEquipment",
    "tEquipmentContainer",
    "tExtRef",
    "tFCDA",
    "tFunction",
    "tGSE",
    "tGSEControl",
    "tGSESettings",
    "tGeneralEquipment",
    "tHeader",
    "tHitem",
    "tIDNaming",
    "tIED",
    "tInputs",
    "tLDevice",
    "tLN",
    "tLN0",
    "tLNode",
    "tLNodeContainer",
    "tLNodeType",
    "tLog",
    "tLogControl",
    "tLogSettings",
    "tNaming",
    "tP",
    "tP_APPID",
    "tP_IP",
    "tP_IP_GATEWAY",
    "tP_IP_SUBNET",
    "tP_MAC_Address",
    "tP_OSI_AE_Invoke",
    "tP_OSI_AE_Qualifier",
    "tP_OSI_AP_Invoke",
    "tP_OSI_AP_Title",
    "tP_OSI_NSAP",
    "tP_OSI_PSEL",
    "tP_OSI_SSEL",
    "tP_OSI_TSEL",
    "tP_VLAN_ID",
    "tP_VLAN_PRIORITY",
    "tPhysConn",
    "tPowerSystemResource",
    "tPowerTransformer",
    "tPrivate",
    "tReportControl",
    "tReportSettings",
    "tRptEnabled",
    "tSCLControl",
    "tSDI",
    "tSDO",
    "tSMV",
    "tSMVSettings",
    "tSampledValueControl",
    "tServer",
    "tServiceSettings",
    "tServiceWithMax",
    "tServiceWithMaxAndClient",
    "tServiceWithMaxAndMaxAttributes",
    "tServiceWithMaxAndMaxAttributesAndModify",
    "tServiceWithMaxAndModify",
    "tServiceYesNo",
    "tServices",
    "tSettingControl",
    "tSubEquipment",
    "tSubFunction",
    "tSubNetwork",
    "tSubstation",
    "tTapChanger",
    "tTerminal",
    "tText",
    "tTransformerWinding",
    "tTrgOps",
    "tUnNaming",
    "tVal",
    "tValueWithUnit",
    "tVoltage",
    "tVoltageLevel"
]
